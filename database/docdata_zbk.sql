/*
SQLyog Professional v12.09 (64 bit)
MySQL - 10.1.23-MariaDB : Database - zbk_blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`zbk_blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `zbk_blog`;

/*Data for the table `doc` */

insert  into `doc`(`doc_id`,`title`,`doc_md`,`tag_id`,`update_time`,`favor_number`,`open_number`) values (92458233954305,'Hibernate一级缓存','#一级缓存\r\n这里是一级缓存测试 xxxf',1495595754168,1498928689314,NULL,41),(92458234085378,'CentOS7 安装 MariaDB','CentOS7以上版本上，不再使用MySQL数据库,而是使用MariaDB数据库,其中MariaDB是MySQL的一个分支.现在写上个人在CentOS7里安装配置MariaDB的步骤:\r\n\r\n#安装和启动\r\n\r\n## 下载安装MariaDB\r\n```shell\r\nyum -y install mariadb-server mariadb\r\n```\r\n\r\n\r\n## 启动MariaDB\r\n\r\n###启动MariaDB服务\r\n```shell\r\n[root@localhost /]# systemctl start mariadb\r\n```\r\n\r\n###设置MariaDB开机默认启动\r\n```shell\r\n[root@localhost /]# systemctl enable mariadb\r\n```\r\n\r\n###查看 MySQL 服务是否开机启动\r\n如果是 enabled 则说明是开机自动\r\n```shell\r\n[root@localhost ~]# systemctl is-enabled mariadb;echo $?\r\nenabled\r\n0\r\n```\r\n\r\n###查看mariadb服务状态\r\n```shell\r\nsystemctl status mariadb\r\n```\r\n\r\n###测试是否成功启动\r\n```shell\r\n[root@localhost /]# mysql\r\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\r\nYour MariaDB connection id is 3\r\nServer version: 5.5.47-MariaDB MariaDB Server\r\n\r\nCopyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.\r\n\r\nType \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n```\r\n\r\n\r\n#初始化配置\r\n\r\n\r\n##默认安装了的数据库\r\n```shell\r\nMariaDB [(none)]> show databases;\r\n+--------------------+\r\n| Database           |\r\n+--------------------+\r\n| information_schema |\r\n| mysql              |\r\n| performance_schema |\r\n| test               |\r\n+--------------------+\r\n4 rows in set (0.00 sec)\r\n```\r\n\r\n\r\n\r\n##运行安全配置向导\r\n>在生产环境里安装完后,建议一定要运行一次mysql_secure_installation安全配置向导\r\n\r\n简单来说，运行向导后全部选y回车就可以，下面是向导设置详解。\r\n```shell\r\n[root@localhost /]# mysql_secure_installation\r\n/usr/bin/mysql_secure_installation: line 379: find_mysql_client: command not found\r\n\r\n\r\nNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB\r\n      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!\r\n\r\n\r\nIn order to log into MariaDB to secure it, we\'ll need the current\r\npassword for the root user.  If you\'ve just installed MariaDB, and\r\nyou haven’t set the root password yet, the password will be blank,\r\nso you should just press enter here.\r\n\r\n\r\n#由于一开始安装MariaDB数据库后, root用户默认密码为空, 所以只需要按Enter键\r\nEnter current password for root (enter for none):\r\nOK, successfully used password, moving on...\r\n\r\n\r\nSetting the root password ensures that nobody can log into the MariaDB\r\nroot user without the proper authorisation.\r\n\r\n\r\n#是否设置root用户的新密码\r\nSet root password? [Y/n] y\r\n \r\n#录入新密码\r\nNew password:\r\n \r\n#确认新密码\r\nRe-enter new password:\r\n \r\nPassword updated successfully!\r\nReloading privilege tables..\r\n ... Success!\r\n\r\n\r\n\r\n\r\nBy default, a MariaDB installation has an anonymous user, allowing anyone\r\nto log into MariaDB without having to have a user account created for\r\nthem.  This is intended only for testing, and to make the installation\r\ngo a bit smoother.  You should remove them before moving into a\r\nproduction environment.\r\n\r\n\r\n#是否删除匿名用户,生产环境建议删除\r\nRemove anonymous users? [Y/n] y\r\n ... Success!\r\n\r\n\r\nNormally, root should only be allowed to connect from \'localhost\'.  This\r\nensures that someone cannot guess at the root password from the network.\r\n\r\n\r\n#是否禁止root远程登录,根据自己的需求选择\r\nDisallow root login remotely? [Y/n] n\r\n ... skipping.\r\n\r\n\r\nBy default, MariaDB comes with a database named \'test\' that anyone can\r\naccess.  This is also intended only for testing, and should be removed\r\nbefore moving into a production environment.\r\n\r\n\r\n#是否删除test数据库\r\nRemove test database and access to it? [Y/n] y\r\n - Dropping test database...\r\n ... Success!\r\n - Removing privileges on test database...\r\n ... Success!\r\n\r\n\r\nReloading the privilege tables will ensure that all changes made so far\r\nwill take effect immediately.\r\n\r\n\r\n#是否重新加载权限表\r\nReload privilege tables now? [Y/n] y\r\n ... Success!\r\n\r\n\r\nCleaning up...\r\n\r\n\r\nAll done!  If you’ve completed all of the above steps, your MariaDB\r\ninstallation should now be secure.\r\n\r\n\r\nThanks for using MariaDB!\r\n```\r\n\r\n##安全设置完成后,测试使用root用户登录操作\r\n```shell\r\n[root@localhost /]# mysql -uroot -p\r\nEnter password:\r\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\r\nYour MariaDB connection id is 13\r\nServer version: 5.5.47-MariaDB MariaDB Server\r\n\r\n\r\nCopyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.\r\n\r\n\r\nType \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n\r\n\r\nMariaDB [(none)]> show databases;\r\n+--------------------+\r\n| Database           |\r\n+--------------------+\r\n| information_schema |\r\n| mysql              |\r\n| performance_schema |\r\n+--------------------+\r\n3 rows in set (0.00 sec)\r\n```\r\n\r\n##退出MariaDB控制台\r\n```shell\r\nMariaDB [(none)]> exit\r\nBye\r\n```\r\n\r\n#远程访问设置\r\n##创建普通访问用户\r\n创建一个普通用户 sa ，密码是 some_pass\r\n```sql\r\nCREATE USER \'sa\'@\'%\' IDENTIFIED BY \'some_pass\';\r\n```\r\n给这个用户授予 SELECT,INSERT,UPDATE,DELETE 的远程访问的权限，这个账号一般用于提供给实施的系统访问\r\n```sql\r\nGRANT SELECT,INSERT,UPDATE,DELETE  ON *.* TO \'sa\'@\'%\';\r\n```\r\n\r\n##创建管理员账户\r\n创建一个管理员用户 admin 账号 ，密码是 some_pass\r\n```sql\r\nCREATE USER \'admin\'@\'%\' IDENTIFIED BY \'some_pass\';\r\n```\r\n给这个用户授予所有的远程访问的权限。这个用户主要用于管理整个数据库、备份、还原等操作。\r\n```sql\r\nGRANT ALL  ON *.* TO \'admin\'@\'%\';\r\n```\r\n\r\n##使授权立刻生效\r\n```sql\r\nflush privileges;\r\n```\r\n\r\n#更改数据存放目录\r\n##创建数据存放目录\r\n`/home` 目录下建立 `data` 目录\r\n\r\n```shell\r\nmkdir /home/data\r\n```\r\n把 MariaDB 服务进程停掉\r\n如果 MariaDB 是启动的，要先关闭\r\n```shell\r\n#查看运行状态\r\nsystemctl status mariadb\r\n```\r\n\r\n##移动数据到数据存放目录\r\n\r\n`/var/lib/mysql` 整个目录移到 `/home/data`，执行\r\n```shell\r\nmv /var/lib/mysql /home/data\r\n```\r\n这样就把 MariaDB 的数据文件移动到了 `/home/data/mysql` 下\r\n\r\n##修改配置文件\r\n修改 `/etc/my.cnf` 文件，\r\n\r\n```shell\r\n[mysqld] \r\ndatadir=/home/data/mysql\r\nsocket=/home/data/mysql/mysql.sock\r\n\r\n[mysql] \r\nsocket=/home/data/mysql/mysql.sock\r\n```\r\n\r\n修改权限\r\n```shell\r\nchown -R mysql:mysql /home/data/mysql\r\n```\r\n重启后，如果不能启动 MariaDB 服务，执行\r\n\r\n```shell\r\nvi  /etc/sysconfig/selinux\r\n```\r\n调整\r\n```shell\r\nSELINUX=permissive\r\n```\r\n或直接关闭selinux\r\n```shell\r\nSELINUX=disabled\r\n```\r\n保存设置，执行 `reboot` 重启生效\r\n\r\n\r\n#设置字符集\r\n一般的，为了支持中文，我们应该讲字符集设为 UTF-8， 在MariaDB控制台执行\r\n```shell\r\nSHOW VARIABLES LIKE \'character%\';\r\n```\r\n查看当前 MySQL 字符集\r\n```shell\r\nmysql>  SHOW VARIABLES LIKE \'character%\';\r\n+--------------------------+----------------------------+\r\n| Variable_name            | Value                      |\r\n+--------------------------+----------------------------+\r\n| character_set_client     | utf8                       |\r\n| character_set_connection | utf8                       |\r\n| character_set_database   | latin1                     |\r\n| character_set_filesystem | binary                     |\r\n| character_set_results    | utf8                       |\r\n| character_set_server     | latin1                     |\r\n| character_set_system     | utf8                       |\r\n| character_sets_dir       | /usr/share/mysql/charsets/ |\r\n+--------------------------+----------------------------+\r\n8 rows in set (0.00 sec)\r\n```\r\n可以看到默认服务器的字符器是 `latin1` ，对中文不友好。\r\n修改 `/etc/my.cnf` 文件，添加字符集的设置\r\n```shell\r\n[mysqld]\r\ncharacter_set_server = utf8\r\n\r\n[mysql]\r\ndefault-character-set = utf8\r\n```\r\n>如果已经有[xxx]则直接在下面添加字符集设置即可，如果没有需要添加[xxx]\r\n\r\n重启 MariaDB ,可以看到字符集已经修改了\r\n\r\n```shell\r\nmysql> SHOW VARIABLES LIKE \'character%\';\r\n+--------------------------+----------------------------+\r\n| Variable_name            | Value                      |\r\n+--------------------------+----------------------------+\r\n| character_set_client     | utf8                       |\r\n| character_set_connection | utf8                       |\r\n| character_set_database   | utf8                       |\r\n| character_set_filesystem | binary                     |\r\n| character_set_results    | utf8                       |\r\n| character_set_server     | utf8                       |\r\n| character_set_system     | utf8                       |\r\n| character_sets_dir       | /usr/share/mysql/charsets/ |\r\n+--------------------------+----------------------------+\r\n8 rows in set (0.00 sec)\r\n```\r\n\r\n#其他常用配置配置\r\n调整 MariaDB 运行参数，修改 `/etc/my.cnf` 文件，常用配置如下：\r\n```shell\r\n[mysqld]\r\nbasedir      = path          # 使用给定目录作为根目录(安装目录)。\r\ndatadir      = path          # 从给定目录读取数据库文件。\r\npid-file     = filename      # 为mysqld程序指定一个存放进程ID的文件(仅适用于UNIX/Linux系统);\r\n\r\n\r\nsocket = /tmp/mysql.sock     # 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是/var/lib/mysql/mysql.sock文件)\r\nport             = 3306      # 指定MsSQL侦听的端口\r\nkey_buffer       = 384M      # key_buffer是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)。\r\n                               索引块是缓冲的并且被所有的线程共享，key_buffer的大小视内存大小而定。\r\ntable_cache      = 512       # 为所有线程打开表的数量。增加该值能增加mysqld要求的文件描述符的数量。可以避免频繁的打开数据表产生的开销\r\nsort_buffer_size = 2M        # 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。\r\n                               注意：该参数对应的分配内存是每连接独占！如果有100个连接，那么实际分配的总共排序缓冲区大小为100×6=600MB\r\nread_buffer_size = 2M        # 读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。\r\nquery_cache_size = 32M       # 指定MySQL查询结果缓冲区的大小\r\nread_rnd_buffer_size    = 8M # 改参数在使用行指针排序之后，随机读用的。\r\nmyisam_sort_buffer_size =64M # MyISAM表发生变化时重新排序所需的缓冲\r\nthread_concurrency      = 8 # 最大并发线程数，取值为服务器逻辑CPU数量×2，如果CPU支持H.T超线程，再×2\r\nthread_cache            = 8 # #缓存可重用的线程数\r\nskip-locking                 # 避免MySQL的外部锁定，减少出错几率增强稳定性。\r\n[mysqldump]\r\nmax_allowed_packet      =16M # 服务器和客户端之间最大能发送的可能信息包\r\n\r\n[myisamchk]\r\nkey_buffer   = 256M\r\nsort_buffer = 256M\r\nread_buffer = 2M\r\nwrite_buffer = 2M\r\n```\r\n##其他可选参数：\r\n```shell\r\nback_log = 384\r\n\r\n#指定MySQL可能的连接数量。 当MySQL主线程在很短时间内接收到非常多的连接请求，该参数生效，主线程花费很短时间检查连接并且启动一个新线程。 back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。 如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。 试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数。\r\n\r\nmax_connections = n\r\n\r\n#MySQL服务器同时处理的数据库连接的最大数量(默认设置是100)。超过限制后会报 Too many connections 错误\r\n\r\nkey_buffer_size = n\r\n\r\n#用来存放索引区块的RMA值(默认设置是8M)，增加它可得到更好处理的索引(对所有读和多重写)\r\n\r\nrecord_buffer：\r\n\r\n#每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。 如果你做很多顺序扫描，你可能想要增加该值。默认数值是131072(128K)\r\n\r\nwait_timeout：\r\n\r\n#服务器在关闭它之前在一个连接上等待行动的秒数。\r\n\r\ninteractive_timeout：\r\n\r\n#服务器在关闭它前在一个交互连接上等待行动的秒数。 一个交互的客户被定义为对 mysql_real_connect()使用 CLIENT_INTERACTIVE 选项的客户。 默认数值是28800，可以把它改为3600。\r\n\r\nskip-name-resolve\r\n\r\n#禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！\r\n\r\nlog-slow-queries = slow.log\r\n\r\n#记录慢查询,然后对慢查询一一优化\r\n\r\nskip-innodb\r\n\r\nskip-bdb\r\n\r\n#关闭不需要的表类型,如果你需要,就不要加上这个\r\n```\r\n\r\n#备份、还原\r\n##方法1:命令行\r\n###备份\r\n```shell\r\nmysqldump --socket=/home/data/mysql/mysql.sock --single-transaction=TRUE  -u root -p emsc > emsc.sql\r\n```\r\n###还原\r\n```shell\r\nmysql --socket=/home/data/mysql/mysql.sock  -u root -p emsc < emsc.sql\r\n```\r\n##方法2:可以使用图形工具进行备份和还原\r\nSQLLyon、HeidiSQL等\r\n',1495603858351,1498928691186,NULL,24),(92458234085379,'上传文件选择框会延迟','editormd编辑器在chrome浏览器里本地上传按钮点了半天才有反应，是因为 `<input type=\"file\" name=\"editormd-image-file\" accept=\"image/*\">` 里边的 `accept=\"image/*\"` 。\r\n\r\n所以，修改了`vendor/bower/editor.md/plugins/image-dialog/image-dialog.js` 第54行为 \r\n```javascript\r\n\"<input type=\\\"file\\\" name=\\\"\" + classPrefix + \"image-file\\\" accept=\\\"image/jpg,image/jpeg,image/png,image/gif\\\" />\" +\r\n```\r\n\r\n总结：accept不要写通配符*,尽量一个一个写\r\n\r\nW3School的建议：\r\n>请避免使用该属性。应该在服务器端验证文件上传。',1495612213284,1498928691232,NULL,11),(92458234085380,'JSTL参考网站','网站地址\r\n[JSTL教程](http://www.yiibai.com/jstl \"JSTL教程\")',1495613640905,1498928691256,NULL,2),(92458234085381,'vmware workstation 命令行','最近需要用到workstation，为了提高效率，研究了一下命令脚本，分享一下\r\n\r\n有错误之处，还望指正：\r\n\r\n我是在[Windows](http://www.jikexueyuan.com/course/windows/)下面的做的实验，首先要切换到对应的目录下面\r\n\r\n`c:/Program Files/VMware/VMware Workstation`\r\n#两个命令\r\n下面有两个文件比较关键，一个是vmare.exe，一个是vmrun.exe\r\n##命令用途\r\n两个命令的用途可以见插图：\r\n\r\nhttp://pubs.vmware.com/workstation-10/index.jsp\\#com.vmware.ws.using.doc/GUID-7369457F-FE1D-40FE-97B6-B29CA4916CCD.html\r\n##命令参数\r\n\r\n[![7983c862885450040f2a211264b5d82d.png](/images/8adc2859-983d-4036-99c4-0c3da523b51f \"7983c862885450040f2a211264b5d82d.png\")](/images/8adc2859-983d-4036-99c4-0c3da523b51f)\r\n\r\n\r\nvmrun操作主要是针对GUEST VM做相应的操作：\r\n[![e71ea1a79780117a557f61d7873fc249.jpg](/images/92f114dd-65fa-46f7-9e39-38eea81b4723 \"e71ea1a79780117a557f61d7873fc249.jpg\")](/images/92f114dd-65fa-46f7-9e39-38eea81b4723)\r\n\r\n\r\n恢复到某个镜像命令：\r\n\r\n```shell\r\nC:\\\\Program Files\\\\VMware\\\\VMware Workstation\\>vmrun -T ws reverttosnapshot \\\\VM\\_OS\\\\002\\\\002.vmx 1\r\n```\r\n\r\n运行windows中的某个程序时，使用命令：\r\n\r\n注意，runProgramInGuest 是常量，非变量\r\n\r\n```shell\r\nvmrun -T ws -gu Administrator -gp 123456 runProgramInGuest \"c:\\\\VM\\_OS\\\\002\\\\002.vmx\" \"C:\\\\Program Files\\\\NetMeeting\\\\conf.exe\"\r\n```\r\n\r\n\r\n#Examples:  \r\n  \r\n  \r\n  \r\n  \r\nStarting a virtual machine with Workstation on a Windows host  \r\n   `vmrun -T ws start \"c:\\\\myVMs\\\\myVM.vmx\"  `\r\n  \r\n  \r\n  \r\n  \r\nStopping a virtual machine on an ESX host  \r\n   `vmrun -T esx -h https://myHost.com/sdk -u hostUser -p hostPassword stop \"[storage1] vm/myVM.vmx\"  `\r\n  \r\n  \r\n  \r\n  \r\nRunning a program in a virtual machine with Workstation on a Windows host with\r\nWindows guest  \r\n   `vmrun -T ws -gu guestUser -gp guestPassword runProgramInGuest \"c:\\\\myVMs\\\\myVM.vmx\" \"c:\\\\Program Files\\\\myProgram.exe\"  `\r\n  \r\n  \r\n  \r\n  \r\nRunning a program in a virtual machine with Server on\r\na [Linux](http://www.jikexueyuan.com/course/linuxsys/) host with Linux guest  \r\n   `vmrun -T server -h https://myHost.com:8333/sdk -u hostUser -p hostPassword -gu guestUser -gp guestPassword runProgramInGuest \"[standard] vm/myVM.vmx\" /usr/bin/X11/xclock -display :0  `\r\n  \r\n  \r\n  \r\n  \r\nCreating a snapshot of a virtual machine with Workstation on a Windows host  \r\n   `vmrun -T ws snapshot \"c:\\\\my VMs\\\\myVM.vmx\" mySnapshot  `\r\n  \r\n  \r\n  \r\n  \r\nReverting to a snapshot with Workstation on a Windows host  \r\n   `vmrun -T ws revertToSnapshot \"c:\\\\my VMs\\\\myVM.vmx\" mySnapshot  `\r\n  \r\n  \r\n  \r\n  \r\nDeleting a snapshot with Workstation on a Windows host  \r\n   `vmrun -T ws deleteSnapshot \"c:\\\\my VMs\\\\myVM.vmx\" mySnapshot  `\r\n  \r\n  \r\n  \r\n  \r\nEnabling Shared Folders with Workstation on a Windows host  \r\n   `vmrun -T ws enableSharedFolders \"c:\\\\my VMs\\\\myVM.vmx\"`\r\n\r\n#我的应用例子\r\n\r\n##开机启动一个虚拟机\r\n\r\n创建一个快捷方式：\r\n`\"C:\\Program Files (x86)\\vmware\\VMware Workstation\\vmware.exe\" -x  \"C:\\Users\\Administrator\\Documents\\Virtual Machines\\Windows 7\\Windows 7.vmx\"`\r\n\r\n把该快捷方式放到启动文件夹\r\n\r\n##后台启动一个虚拟机\r\n创建一个快捷方式(如果多台虚拟机，可以写到一个bat脚本中)\r\n`\"D:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun.exe\" -T ws start \"E:\\虚拟机\\webapp服务器-CentOS7x64\\webapp服务器-CentOS7x64.vmx\" nogui`\r\n\r\n放入启动文件夹\r\n',1495632064768,1498928691294,NULL,11),(92458234085382,'CentOS7x64安装jdk1.8 for tar.gz包','#使用WinSCP或其他SCP工具上传jdk1.8\r\n```shell\r\n[root@edu-provider-01 ~]# ls\r\nanaconda-ks.cfg  jdk-8u121-linux-x64.tar.gz\r\n```\r\n#解压tar.gz包\r\n```shell\r\n[root@edu-provider-01 ~]# tar -xzvf jdk-8u121-linux-x64.tar.gz -C /usr/local\r\n```\r\n#配置JAVA_HOME等环境变量\r\n```shell\r\n[root@edu-provider-01 ~]# cd /usr/local/jdk1.8.0_121/\r\n[root@edu-provider-01 jdk1.8.0_121]# pwd >> /etc/profile\r\n[root@edu-provider-01 ~]# vi /etc/profile\r\n```\r\n在最后添加\r\n```shell\r\nexport JAVA_HOME=/usr/local/jdk1.8.0_121\r\nexport PATH=$JAVA_HOME/bin:$PATH\r\nexport CLASSPATH=$JAVA_HOME/lib/\r\n```\r\nsource环境变量\r\n```shell\r\n[root@edu-provider-01 ~]# source /etc/profile\r\n```\r\n测试环境变量是否配置成功\r\n```shell\r\n[root@edu-provider-01 ~]# java -version\r\njava version \"1.8.0_121\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\r\n```',1495769522659,1498928691324,NULL,4),(92458234085383,'Java 一个简单的线程定时 （守护线程+退出标志）','#守护进程\r\n守护线程也叫精灵线程: 当程序只剩下守护线程的时候 ,程序就会退出。\r\n\r\n守护线程的作用类似在后台静默执行，比如JVM的垃圾回收机制。\r\n\r\n##守护线程应用场景\r\n应用场景：实例化socket连接时需要判断连接成功与否，一般来说，如果连接成功就是片刻的事，如果不成功的话jvm会判断20s时间，才会抛出超时异常，对于体验来说实在是太差了，所以就需要自定义他运行时间，超过时间（比如2s）就抛出异常，终止程序。\r\n\r\n#主代码\r\n>TimeoutThreadDemo.Java\r\n\r\n```java\r\npublic class TimeoutThreadDemo extends Thread {\r\n    private long timeout;\r\n    private boolean isCanceled = false;\r\n    private TimeoutException timeoutException;\r\n\r\n    public TimeoutThreadDemo(long timeout, TimeoutException timeoutErr) {\r\n        this.timeout = timeout; //超时时长\r\n        this.timeoutException = timeoutErr;//抛出自定义异常\r\n        this.setDaemon(true); //设置成为守护线程\r\n    }\r\n\r\n    public synchronized void cancel() {\r\n        isCanceled = true;\r\n    }\r\n\r\n    public void run() {\r\n        try {\r\n            Thread.sleep(timeout);//线程休眠2s后运行\r\n            if (!isCanceled)\r\n                throw timeoutException;\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TimeoutThreadDemo t = new TimeoutThreadDemo(2000, new TimeoutException(\"超时啦！\")); //2000为2s，这里需要设置多少自行输入\r\n        try {\r\n            t.start();\r\n            /*\r\n            这里需要说明一下，t.start()和t.cancel()之间是我们要操作定时完成的对象，t.start()线程运行，我们规定的是让它先休眠2s，接下来执行我们的操作，如果我们的操作2s内执行完毕，就执行t.cancel()把isCancel参数设置为true，跳出异常抛出操作。反之，2s内我们的操作未完成，则t.start()的2s时间到了，t.cancel()未执行，isCancel未更改就会执行异常抛出操作了\r\n            */\r\n            Thread thread = new Thread() {\r\n                @Override\r\n                public void run() {\r\n                    // TODO Auto-generated method stub\r\n                /*这里请注意，新开线程只是为了使用thread.sleep();方法\r\n                从而实现超时目的，不能在本线程中进行耗时操作，比如实例化socket（系统默认20s超时时间），新开线程的话不在超时监测线程中作业，就达不到监测目的\r\n                */\r\n                }\r\n            };\r\n\r\n            try {\r\n                thread.sleep(10000);\r\n            } catch (InterruptedException e) {\r\n                // TODO Auto-generated catch block\r\n                e.printStackTrace();\r\n            }\r\n            thread.start();\r\n            t.cancel();//更改isCanccel的值\r\n        } catch (TimeoutException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n}\r\n\r\n//自定义异常类\r\nclass TimeoutException extends RuntimeException {\r\n    private static final long serialVersionUID = -8078853655388692688L;\r\n\r\n    public TimeoutException(String errMessage) {\r\n        super(errMessage);\r\n    }\r\n}\r\n```\r\n\r\n#效果\r\n未使用守护线程时，需要等十秒，等程序自然结束。\r\n\r\n使用守护线程，当过了自定义时间程序还没有结束，就会结束线程并抛出自定义异常。',1496285102417,1498928691359,NULL,4),(92458234085384,'更改MySQL数据库编码为utf8mb4','#UTF-8编码和utf8mb4编码\r\n\r\nutf-8编码可能2个字节、3个字节、4个字节的字符，但是MySQL的utf8编码只支持3字节的数据，而移动端的表情数据是4个字节的字符。如果直接往采用utf-8编码的数据库中插入表情数据，Java程序中将报SQL异常：\r\n```java\r\njava.sql.SQLException: **Incorrect string value**: ‘\\\\xF0\\\\x9F\\\\x92\\\\x94’ for\r\ncolumn ‘name’ at row 1  \r\nat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1073)   \r\nat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3593)   \r\nat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3525)   \r\nat com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1986)   \r\nat com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2140)   \r\nat com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2620)   \r\nat com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1662)   \r\nat com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1581)\r\n```\r\n\r\n可以对4字节的字符进行编码存储，然后取出来的时候，再进行解码。但是这样做会使得任何使用该字符的地方都要进行编码与解码。\r\n\r\nutf8mb4编码是utf8编码的超集，兼容utf8，并且能存储4字节的表情字符。   \r\n采用utf8mb4编码的好处是：存储与获取数据的时候，不用再考虑表情字符的编码与解码问题。\r\n\r\n#更改数据库的编码为utf8mb4:\r\n\r\n##1. MySQL的版本\r\n\r\nutf8mb4的最低mysql版本支持版本为5.5.3+，若不是，请升级到较新版本。\r\n\r\n##2. MySQL驱动\r\n\r\n5.1.34可用,最低不能低于5.1.13\r\n\r\n##3.修改MySQL配置文件\r\n\r\n修改mysql配置文件my.cnf（windows为my.ini）   \r\nmy.cnf一般在etc/mysql/my.cnf位置。找到后请在以下三部分里添加如下内容：  \r\n```shell \r\n[client]   \r\ndefault-character-set = utf8mb4   \r\n[mysql]   \r\ndefault-character-set = utf8mb4   \r\n[mysqld]   \r\ncharacter-set-client-handshake = FALSE   \r\ncharacter-set-server = utf8mb4   \r\ncollation-server = utf8mb4\\_unicode\\_ci   \r\ninit\\_connect=\'SET NAMES utf8mb4\'\r\n```\r\n\r\n##4. 重启数据库，检查变量\r\n\r\n```shell\r\nSHOW VARIABLES WHERE Variable\\_name LIKE \'character\\_set\\_%\' OR Variable\\_name\r\nLIKE \'collation%\';\r\n```\r\n\r\n| **Variable\\_name**         | **Value**            |\r\n|----------------------------|----------------------|\r\n| character\\_set\\_client     | utf8mb4              |\r\n| character\\_set\\_connection | utf8mb4              |\r\n| character\\_set\\_database   | utf8mb4              |\r\n| character\\_set\\_filesystem | binary               |\r\n| character\\_set\\_results    | utf8mb4              |\r\n| character\\_set\\_server     | utf8mb4              |\r\n| character\\_set\\_system     | utf8                 |\r\n| collation\\_connection      | utf8mb4\\_unicode\\_ci |\r\n| collation\\_database        | utf8mb4\\_unicode\\_ci |\r\n| collation\\_server          | utf8mb4\\_unicode\\_ci |\r\n\r\n`collation\\_connection `、`collation\\_database `、`collation\\_server`是什么没关系。\r\n\r\n但必须保证\r\n\r\n| **系统变量**               | **描述**                     |\r\n|----------------------------|------------------------------|\r\n| character\\_set\\_client     | (客户端来源数据使用的字符集) |\r\n| character\\_set\\_connection | (连接层字符集)               |\r\n| character\\_set\\_database   | (当前选中数据库的默认字符集) |\r\n| character\\_set\\_results    | (查询结果字符集)             |\r\n| character\\_set\\_server     | (默认的内部操作字符集)       |\r\n\r\n这几个变量必须是utf8mb4。\r\n\r\n##5. 数据库连接的配置\r\n\r\n数据库连接参数中:   \r\n`characterEncoding=utf8`会被自动识别为utf8mb4，也可以不加这个参数，会自动检测。   \r\n而`autoReconnect=true`是必须加上的。\r\n\r\n##6. 将数据库和已经建好的表也转换成utf8mb4\r\n\r\n更改数据库编码：\r\n```shell\r\nALTER DATABASE database\\_name CHARACTER SET utf8mb4 COLLATE utf8mb4\\_general\\_ci;\r\n```\r\n\r\n更改表编码：\r\n```shell\r\nALTER TABLE table\\_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4\\_general\\_ci; \r\n```\r\n\r\n如有必要，还可以更改列的编码\r\n',1496399229721,1498928691380,NULL,8),(92458234085385,'(转)Java中的Filter过滤器的使用','#Filter简介\r\n\r\nFilter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。\r\n\r\n它主要用于对用户请求进行预处理，也可以对`HttpServletResponse`进行后处理。使用Filter的完整流程：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。\r\n\r\n#Filter功能\r\n\r\n在`HttpServletRequest`到达 Servlet 之前，拦截客户的`HttpServletRequest` 。根据需要检查`HttpServletRequest`，也可以修改`HttpServletRequest` 头和数据。\r\n在`HttpServletResponse`到达客户端之前，拦截`HttpServletResponse` 。根据需要检查`HttpServletResponse`，也可以修改`HttpServletResponse`头和数据。\r\n\r\n#如何借助Filter实现拦截功能\r\n\r\nFilter接口中有一个`doFilter`方法，当开发人员编写好Filter，并配置对哪个web资源进行拦截后，Web服务器每次在调用web资源的service方法之前，都会先调用一下filter的`doFilter`方法，因此，在该方法内编写代码可达到如下目的：\r\n\r\n- 调用目标资源之前，让一段代码执行。\r\n\r\n- 是否调用目标资源（即是否让用户访问web资源）。\r\n\r\nweb服务器在调用`doFilter`方法时，会传递一个`filterChain`对象进来，`filterChain`对象是filter接口中最重要的一个对象，它也提供了一个`doFilter`方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。\r\n\r\n#Filter开发两步走\r\n\r\n- 编写java类实现Filter接口，并实现其doFilter方法。\r\n- 在web.xml文件中对编写的filter类进行注册，并设置它所能拦截的资源。\r\n\r\n`web.xml`配置各节点介绍：\r\n\r\n\r\n`<filter>`指定一个过滤器。\r\n`<filter-name>`用于为过滤器指定一个名字，该元素的内容不能为空。\r\n`<filter-class>`元素用于指定过滤器的完整的限定类名。\r\n`<init-param>`元素用于为过滤器指定初始化参数，它的子元素`<param-name>`指定参数的名字，`<param-value>`指定参数的值。\r\n在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。\r\n`<filter-mapping>`元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径\r\n`<filter-name>`子元素用于设置filter的注册名称。该值必须是在`<filter>`元素中声明过的过滤器的名字\r\n`<url-pattern>`设置 filter 所拦截的请求路径(过滤器关联的URL样式)\r\n`<servlet-name>`指定过滤器所拦截的Servlet名称。\r\n`<dispatcher>`指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个`<dispatcher>`子元素用来指定 Filter 对资源的多种调用方式进行拦截。\r\n`<dispatcher>`子元素可以设置的值及其意义\r\n`REQUEST`：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过`RequestDispatcher的include()`或`forward()`方法访问时，那么该过滤器就不会被调用。\r\n`INCLUDE`：如果目标资源是通过`RequestDispatcher`的`include()`方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。\r\n`FORWARD`：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。\r\n`ERROR`：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。\r\n\r\n#Filter链\r\n\r\n在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。\r\n\r\nweb服务器根据Filter在`web.xml`文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的`doFilter`方法被调用时，web服务器会创建一个代表Filter链的`FilterChain`对象传递给该方法。在`doFilter`方法中，开发人员如果调用了`FilterChain`对象的`doFilter`方法，则web服务器会检查`FilterChain`对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。\r\n\r\n#Filter的生命周期\r\n\r\n```java\r\npublic void init(FilterConfig filterConfig) throws ServletException;//初始化\r\n\r\n和我们编写的Servlet程序一样，Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的`FilterConfig`对象。\r\n\r\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;//拦截请求\r\n这个方法完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器。\r\n\r\npublic void destroy();//销毁\r\nFilter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。\r\n```\r\n\r\n#FilterConfig接口\r\n\r\n用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：\r\n\r\n```java\r\nString getFilterName();//得到filter的名称。 \r\nString getInitParameter(String name);//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. \r\nEnumeration getInitParameterNames();//返回过滤器的所有初始化参数的名字的枚举集合。 \r\npublic ServletContext getServletContext();//返回Servlet上下文对象的引用。\r\n```\r\n\r\n#Filter使用案例\r\n\r\n##使用Filter验证用户登录安全控制\r\n\r\n前段时间参与维护一个项目，用户退出系统后，再去地址栏访问历史，根据url，仍然能够进入系统响应页面。我去检查一下发现对请求未进行过滤验证用户登录。添加一个filter搞定问题！\r\n\r\n- 先在`web.xml`配置\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>SessionFilter</filter-name>\r\n    <filter-class>com.action.login.SessionFilter</filter-class>\r\n    <init-param>\r\n        <param-name>logonStrings</param-name><!-- 对登录页面不进行过滤 -->\r\n        <param-value>/project/index.jsp;login.do</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>includeStrings</param-name><!-- 只对指定过滤参数后缀进行过滤 -->\r\n        <param-value>.do;.jsp</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>redirectPath</param-name><!-- 未通过跳转到登录界面 -->\r\n        <param-value>/index.jsp</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>disabletestfilter</param-name><!-- Y:过滤无效 -->\r\n        <param-value>N</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>SessionFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n- 接着编写FilterServlet\r\n\r\n```java\r\npackage com.action.login;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.Filter;\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.FilterConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpServletResponseWrapper;\r\n\r\n/**\r\n *    判断用户是否登录,未登录则退出系统\r\n */\r\npublic class SessionFilter implements Filter {\r\n\r\n    public FilterConfig config;\r\n\r\n    public void destroy() {\r\n        this.config = null;\r\n    }\r\n\r\n    public static boolean isContains(String container, String[] regx) {\r\n        boolean result = false;\r\n\r\n        for (int i = 0; i < regx.length; i++) {\r\n            if (container.indexOf(regx[i]) != -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\r\n        HttpServletRequest hrequest = (HttpServletRequest)request;\r\n        HttpServletResponseWrapper wrapper = new HttpServletResponseWrapper((HttpServletResponse) response);\r\n\r\n        String logonStrings = config.getInitParameter(\"logonStrings\");        // 登录登陆页面\r\n        String includeStrings = config.getInitParameter(\"includeStrings\");    // 过滤资源后缀参数\r\n        String redirectPath = hrequest.getContextPath() + config.getInitParameter(\"redirectPath\");// 没有登陆转向页面\r\n        String disabletestfilter = config.getInitParameter(\"disabletestfilter\");// 过滤器是否有效\r\n\r\n        if (disabletestfilter.toUpperCase().equals(\"Y\")) {    // 过滤无效\r\n            chain.doFilter(request, response);\r\n            return;\r\n        }\r\n        String[] logonList = logonStrings.split(\";\");\r\n        String[] includeList = includeStrings.split(\";\");\r\n\r\n        if (!this.isContains(hrequest.getRequestURI(), includeList)) {// 只对指定过滤参数后缀进行过滤\r\n            chain.doFilter(request, response);\r\n            return;\r\n        }\r\n\r\n        if (this.isContains(hrequest.getRequestURI(), logonList)) {// 对登录页面不进行过滤\r\n            chain.doFilter(request, response);\r\n            return;\r\n        }\r\n\r\n        String user = ( String ) hrequest.getSession().getAttribute(\"useronly\");//判断用户是否登录\r\n        if (user == null) {\r\n            wrapper.sendRedirect(redirectPath);\r\n            return;\r\n        }else {\r\n            chain.doFilter(request, response);\r\n            return;\r\n        }\r\n    }\r\n\r\n    public void init(FilterConfig filterConfig) throws ServletException {\r\n        config = filterConfig;\r\n    }\r\n}\r\n```\r\n\r\n这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录。\r\n\r\n##防止中文乱码过滤器\r\n\r\n项目使用spring框架时。当前台JSP页面和Java代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题，那就可以使用这个过滤器。\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>encoding</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name><!--用来指定一个具体的字符集-->\r\n        <param-value>UTF-8</param-value>\r\n    </init-param>\r\n    <init-param>\r\n        <param-name>forceEncoding</param-name><!--true：无论request是否指定了字符集，都是用encoding；false：如果request已指定一个字符集，则不使用encoding-->\r\n        <param-value>false</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>encoding</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n',1496505094236,1498928691411,NULL,2),(92458234085386,'Javascript 判断是否存在函数的方法','```javascript\r\nwindow.onload = function () {\r\n    try {\r\n\r\n        if (test && typeof(test) == \"function\") {\r\n            test();\r\n        } else {\r\n            alert(\"不存在的函数\");\r\n        }\r\n    } catch (e) {\r\n    }\r\n}\r\nfunction test() {\r\n    alert(\"函数执行……\");\r\n}\r\n```\r\n如果不存在，会抛出异常，所以要加try……catch。',1496655931289,1498928691443,NULL,2),(92458234085387,'(转)systemd.service 中文手册','原文链接：<http://www.jinbuguo.com/systemd/systemd.service.html>\r\n\r\n非常感谢译者！！！\r\n\r\n-----------------------------\r\n\r\nsystemd.service 中文手册\r\n========================\r\n\r\n译者：[金步国](http://www.jinbuguo.com/)\r\n\r\n----------------------------------------\r\n\r\n### 版权声明\r\n\r\n本文译者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。\r\n\r\n-   无担保：本文译者不保证译文内容准确无误，亦不承担任何由于使用此文档所导致的损失。\r\n\r\n-   自由使用：任何人都可以自由的*阅读/链接/打印*此文档，无需任何附加条件。\r\n\r\n-   名誉权：任何人都可以自由的*转载/引用/再创作*此文档，但必须保留译者署名并注明出处。\r\n\r\n### 其他作品\r\n\r\n本文译者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：\r\n\r\n-   [金步国作品集](http://www.jinbuguo.com/) [ <http://www.jinbuguo.com/> ]\r\n\r\n### 联系方式\r\n\r\n由于译者水平有限，因此不能保证译文内容准确无误。如果你发现了译文中的错误(哪怕是错别字也好)，请来信指出，任何提高译文质量的建议我都将虚心接纳。\r\n\r\n-   Email(QQ)：70171448在QQ邮箱\r\n\r\n[手册索引](http://www.jinbuguo.com/systemd/systemd.index.html) . [指令索引](http://www.jinbuguo.com/systemd/systemd.directives.html)systemd-231\r\n\r\n名称\r\n----\r\n\r\nsystemd.service — 服务单元配置\r\n\r\n大纲\r\n----\r\n\r\n*service*.service\r\n\r\n描述\r\n----\r\n\r\n以 .service 为后缀的单元文件， 封装了一个被 systemd 监视与控制的进程。\r\n\r\n本手册列出了所有专用于此类单元的配置选项(亦称\"配置指令\"或\"单元属性\")。 [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html) 中描述了通用于所有单元类型的配置选项，\r\n它们位于 \"[Unit]\" 与 \"[Install]\" 小节。 此类单元专用的配置选项位于 \"[Service]\"\r\n小节。\r\n\r\n其他可用的选项参见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 手册(定义了命令的执行环境)，\r\n以及 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册(定义了如何结束进程)，\r\n以及 [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html) 手册(定义了进程的资源控制)。\r\n\r\n如果要求启动或停止的某个单元文件不存在， systemd\r\n将会寻找同名的SysV初始化脚本(去掉 .service 后缀)，\r\n并根据那个同名脚本动态的创建一个 service 单元。\r\n这主要用于与传统的SysV兼容(不能保证100%兼容)。\r\n更多与SysV的兼容性可参见 [Incompatibilities with\r\nSysV](http://www.freedesktop.org/wiki/Software/systemd/Incompatibilities) 文档。\r\n\r\n自动依赖\r\n--------\r\n\r\n设置了 Type=dbus 的服务会自动添加 Requires=dbus.socket 与 After=dbus.socket 依赖。\r\n\r\n基于套接字启动的服务会自动添加对关联 .socket 单元的 After= 依赖。\r\n\r\n除非在 \"[Unit]\" 小节中明确设置了 DefaultDependencies=no ， 否则 service\r\n单元都将自动隐含如下依赖： Requires=sysinit.target, After=sysinit.target, After=basic.target, Conflicts=shutdown.target, Before=shutdown.target 。\r\n这样可以确保普通的服务单元：\r\n(1)在基础系统启动完毕之后才开始启动，(2)在关闭系统之前先被干净的停止。\r\n只有那些需要在系统启动的早期就必须启动的服务，\r\n以及那些必须在关机动作的结尾才能停止的服务才需要设置 DefaultDependencies=no 。\r\n\r\n从同一个模版实例化出来的所有服务单元(单元名称中带有 \"\\@\" 字符)，\r\n默认全部属于与模版同名的同一个 slice\r\n单元(参见 [systemd.slice(5)](http://www.jinbuguo.com/systemd/systemd.slice.html))。\r\n该同名 slice 一般在系统关机时，与所有模版实例一起停止。\r\n如果你不希望像上面这样，那么可以在模版单元中明确设置 DefaultDependencies=no ，\r\n并且：要么在该模版文件中明确定义特定的 slice\r\n单元(同样也要明确设置 DefaultDependencies=no)、\r\n要么在该模版文件中明确设置 Slice=system.slice (或其他合适的 slice)。\r\n参见 [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html) 手册。\r\n\r\n[systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 与 [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html) 中的某些资源限制选项也会自动隐含的添加一些其他的依赖关系。\r\n\r\n选项\r\n----\r\n\r\n每个服务单元文件都必须包含一个 [Service] 小节。\r\n由于此小节中的许多选项也同时适用于其他类型的单元，\r\n所以本手册仅记录了专用于服务单元的选项。\r\n其他共享的选项参见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 与 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册。\r\n这里只列出仅能用于 [Service] 小节的选项(亦称\"指令\"或\"属性\")：\r\n\r\nType=\r\n\r\n>   设置进程的启动类型，\r\n>   必须设为 simple, forking, oneshot, dbus, notify, idle 之一。\r\n\r\n>   如果设为 simple (设置了 ExecStart= 但未设置 BusName= 时的默认值)，\r\n>   那么表示 ExecStart= 进程就是该服务的主进程。\r\n>   如果此进程需要为其他进程提供服务，\r\n>   那么必须在该进程启动之前先建立好通信渠道(例如套接字)，\r\n>   以加快后继单元的启动速度。\r\n\r\n>   如果设为 forking ，\r\n>   那么表示 ExecStart= 进程将会在启动过程中使用 fork() 系统调用。\r\n>   这是传统UNIX守护进程的经典做法。\r\n>   也就是当所有的通信渠道都已建好、启动亦已成功之后，\r\n>   父进程将会退出，而子进程将作为该服务的主进程继续运行。 对于此种进程，\r\n>   建议同时设置 PIDFile= 选项， 以帮助 systemd 准确定位该服务的主进程，\r\n>   进而加快后继单元的启动速度。\r\n\r\n>   oneshot (未设置 ExecStart= 时的默认值) 与 simple 类似，\r\n>   不同之处在于该进程必须在 systemd 启动后继单元之前退出。\r\n>   此种类型通常需要设置 RemainAfterExit= 选项。\r\n\r\n>   dbus (设置了 ExecStart= 也设置了 BusName= 时的默认值) 与 simple 类似，\r\n>   不同之处在于该进程需要在 D-Bus 上获得一个由 BusName= 指定的名称。 systemd\r\n>   将会在启动后继单元之前， 首先确保该进程已经成功的获取了指定的 D-Bus 名称。\r\n>   设为此类型相当于隐含的依赖于 dbus.socket 单元。\r\n\r\n>   notify 与 simple 类似，\r\n>   不同之处在于该进程将会在启动完成之后通过 [sd\\_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html) 之类的接口发送一个通知消息。\r\n>   systemd 将会在启动后继单元之前， 首先确保该进程已经成功的发送了这个消息。\r\n>   如果设为此类型， 那么 NotifyAccess= 将只能设为all 或 main 之一，\r\n>   并且 NotifyAccess= 的默认值 也会变为 main 。\r\n>   注意，目前 Type=notify 尚不能在 PrivateNetwork=yes 的情况下正常工作。\r\n\r\n>   idle 与 simple 类似，\r\n>   不同之处在于该进程将会被延迟到所有的操作都完成之后再执行。\r\n>   这样可以避免控制台上的状态信息 与shell脚本的输出混杂在一起。\r\n\r\nRemainAfterExit=\r\n\r\n>   当该服务的所有进程全部退出之后， 是否依然将此服务视为活动(active)状态。\r\n>   默认值为 no\r\n\r\nGuessMainPID=\r\n\r\n>   在无法明确定位该服务主进程的情况下， systemd\r\n>   是否应该猜测主进程的PID(可能不正确)。\r\n>   该选项仅在设置了 Type=forking 但未设置 PIDFile= 的情况下有意义。\r\n>   如果PID猜测错误， 那么该服务的失败检测与自动重启功能将失效。 默认值为 yes\r\n\r\nPIDFile=\r\n\r\n>   守护进程的PID文件，必须是绝对路径。\r\n>   强烈建议在 Type=forking 的情况下明确设置此选项。 systemd\r\n>   将会在此服务启动后从此文件中读取主守护进程的PID 。 systemd 不会写入此文件，\r\n>   但会在此服务停止后删除它(若存在)。\r\n\r\nBusName=\r\n\r\n>   设置与此服务通信所使用的 D-Bus 名称。 在 Type=dbus 的情况下\r\n>   必须明确设置此选项。\r\n\r\nExecStart=\r\n\r\n>   在启动该服务时需要执行的命令行(命令+参数)。\r\n>   有关命令行的更多细节可参见后文的\"命令行\"小节。\r\n\r\n>   仅在设置了 Type=oneshot 的情况下， 才可以设置任意个命令行(包括零个)，\r\n>   否则必须且只能设置一个命令行。 多个命令行既可以在同一个 ExecStart= 中设置，\r\n>   也可以通过设置多个 ExecStart= 来达到相同的效果。\r\n>   如果设为一个空字符串，那么先前设置的所有命令行都将被清空。\r\n>   如果不设置任何 ExecStart= 指令，\r\n>   那么必须确保设置了 RemainAfterExit=yes 指令。\r\n\r\n>   命令行必须以一个绝对路径表示的可执行文件开始，并且其后的那些参数将依次作为\"argv[1]\r\n>   argv[2] ...\"传递给被执行的进程。 如果在绝对路径前加上可选的 \"\\@\"\r\n>   前缀，那么其后的那些参数将依次作为\"argv[0] argv[1] argv[2]\r\n>   ...\"传递给被执行的进程。 如果在绝对路径前加上可选的 \"-\"\r\n>   前缀，那么即使该进程以失败状态(例如非零的返回值或者出现异常)退出，也会被视为成功退出。\r\n>   如果在绝对路径前加上可选的 \"+\"\r\n>   前缀，那么进程将拥有完全的权限(超级用户的特权)。 可以同时使用 \"-\", \"\\@\", \"+\"\r\n>   前缀， 且顺序任意。\r\n\r\n>   如果设置了多个命令行， 那么这些命令行将以其在单元文件中出现的顺序依次执行。\r\n>   如果某个无 \"-\" 前缀的命令行执行失败， 那么剩余的命令行将不会被继续执行，\r\n>   同时该单元将变为失败(failed)状态。\r\n\r\n>   当未设置 Type=forking 时， 这里设置的命令行所启动的进程\r\n>   将被视为该服务的主守护进程。\r\n\r\nExecStartPre=, ExecStartPost=\r\n\r\n>   设置在执行 ExecStart= 之前/后执行的命令行。 语法规则与 ExecStart= 完全相同。\r\n>   如果设置了多个命令行， 那么这些命令行将以其在单元文件中出现的顺序依次执行。\r\n\r\n>   如果某个无 \"-\" 前缀的命令行执行失败， 那么剩余的命令行将不会被继续执行，\r\n>   同时该单元将变为失败(failed)状态。\r\n\r\n>   仅在所有无 \"-\" 前缀的 ExecStartPre= 命令全部执行成功的前提下，\r\n>   才会继续执行 ExecStart= 命令。\r\n\r\n>   ExecStartPost= 命令仅在服务已经启动成功之后才会运行，判断的标准基于 Type= 选项。\r\n>   具体说来，对于 Type=simple 或 Type=idle 就是主进程已经成功启动；\r\n>   对于 Type=oneshot 来说就是主进程已经成功退出；\r\n>   对于 Type=forking 来说就是初始进程已经成功退出；\r\n>   对于 Type=notify 来说就是已经发送了 \"READY=1\" ；\r\n>   对于 Type=dbus 来说就是已经取得了 BusName= 中设置的总线名称。\r\n\r\n>   注意，不可将 ExecStartPre= 用于需要长时间执行的进程。\r\n>   因为所有由 ExecStartPre= 派生的子进程\r\n>   都会在启动 ExecStart= 服务进程之前被杀死。\r\n\r\n>   注意，如果在服务启动完成之前，任意一个 ExecStartPre=, ExecStart=, ExecStartPost= 中无\r\n>   \"-\" 前缀的命令执行失败或超时，\r\n>   那么，ExecStopPost= 将会被继续执行，而 ExecStop= 则会被跳过。\r\n\r\nExecReload=\r\n\r\n>   这是一个可选的指令， 用于设置当该服务被要求重新载入配置时所执行的命令行。\r\n>   语法规则与 ExecStart= 完全相同。\r\n\r\n>   另外，还有一个特殊的环境变量 \\$MAINPID 可用于表示主进程的PID，\r\n>   例如可以这样使用：\r\n\r\n>   /bin/kill -HUP \\$MAINPID\r\n\r\n>   注意，像上例那样，通过向守护进程发送复位信号，\r\n>   强制其重新加载配置文件，并不是一个好习惯。 因为这是一个异步操作，\r\n>   所以不适用于需要按照特定顺序重新加载配置文件的服务。\r\n>   我们强烈建议将 ExecReload= 设为一个\r\n>   能够确保重新加载配置文件的操作同步完成的命令行。\r\n\r\nExecStop=\r\n\r\n>   这是一个可选的指令， 用于设置当该服务被要求停止时所执行的命令行。\r\n>   语法规则与 ExecStart= 完全相同。 执行完此处设置的命令行之后，\r\n>   该服务所有剩余的进程将会根据 KillMode= 的设置被杀死(参见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html))。\r\n>   如果未设置此选项，那么当此服务被停止时，\r\n>   该服务的所有进程都将会根据 KillSignal= 的设置被立即全部杀死。\r\n>   与 ExecReload= 一样， 也有一个特殊的环境变量 \\$MAINPID 可用于表示主进程的PID\r\n\r\n>   一般来说， 仅仅设置一个结束服务的命令而不等待其完成， 是不够的。\r\n>   因为当此处设置的命令执行完之后， 剩余的进程会被 SIGKILL 信号立即杀死，\r\n>   这可能会导致数据丢失。 因此，这里设置的命令必须是同步操作，\r\n>   而不能是异步操作。\r\n\r\n>   注意，仅在服务确实启动成功的前提下，才会执行 ExecStop= 中设置的命令。\r\n>   如果服务从未启动或启动失败(例如，任意一个 ExecStart=, ExecStartPre=, ExecStartPost= 中无\r\n>   \"-\" 前缀的命令执行失败或超时)， 那么 ExecStop= 将会被跳过。\r\n>   如果想要无条件的在服务停止后执行特定的动作，那么应该使用 ExecStopPost= 选项。\r\n\r\n>   应该将此选项用于那些必须在服务干净的退出之前执行的命令。\r\n>   当此选项设置的命令被执行的时候，应该假定服务正处于完全正常的运行状态，可以正常的与其通信。\r\n>   如果想要无条件的在服务停止后\"清理尸体\"，那么应该使用 ExecStopPost= 选项。\r\n\r\nExecStopPost=\r\n\r\n>   这是一个可选的指令， 用于设置在该服务停止之后所执行的命令行。\r\n>   语法规则与 ExecStart= 完全相同。\r\n>   注意，与 ExecStop= 不同，无论服务是否启动成功，\r\n>   此选项中设置的命令都会在服务停止后被无条件的执行。\r\n\r\n>   应该将此选项用于设置那些无论服务是否启动成功都必须在服务停止后无条件执行的清理操作。\r\n>   此选项设置的命令必须能够正确处理由于服务启动失败而造成的各种残缺不全以及数据不一致的场景。\r\n>   由于此选项设置的命令在执行时，整个服务的所有进程都已经全部结束，所以无法与服务进行任何通信。\r\n\r\nRestartSec=\r\n\r\n>   设置在重启服务(Restart=)前暂停多长时间。 默认值是100毫秒(100ms)。\r\n>   如果未指定时间单位，那么将视为以秒为单位。 例如设为\"20\"等价于设为\"20s\"。\r\n\r\nTimeoutStartSec=\r\n\r\n>   设置该服务允许的最大启动时长。\r\n>   如果守护进程未能在限定的时长内发出\"启动完毕\"的信号，那么该服务将被视为启动失败，并会被关闭。\r\n>   如果未指定时间单位，那么将视为以秒为单位。 例如设为\"20\"等价于设为\"20s\"。\r\n>   设为 \"infinity\" 则表示永不超时。 当 Type=oneshot 时， 默认值为 \"infinity\"\r\n>   (永不超时)，\r\n>   否则默认值等于 DefaultTimeoutStartSec= 的值(参见 [systemd-system.conf(5)](http://www.jinbuguo.com/systemd/systemd-system.conf.html) 手册)。\r\n\r\nTimeoutStopSec=\r\n\r\n>   设置该服务允许的最大停止时长。 如果该服务未能在限定的时长内成功停止，\r\n>   那么将会被强制使用 SIGTERM 信号关闭， 如果依然未能在相同的时长内成功停止，\r\n>   那么将会被强制使用 SIGKILL 信号关闭(参见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册中的 KillMode= 选项)。\r\n>   如果未指定时间单位，那么将视为以秒为单位。 例如设为\"20\"等价于设为\"20s\"。\r\n>   设为 \"infinity\" 则表示永不超时。\r\n>   默认值等于 DefaultTimeoutStopSec= 的值(参见 [systemd-system.conf(5)](http://www.jinbuguo.com/systemd/systemd-system.conf.html) 手册)。\r\n\r\nTimeoutSec=\r\n\r\n>   一个同时设置 TimeoutStartSec= 与 TimeoutStopSec= 的快捷方式。\r\n\r\nRuntimeMaxSec=\r\n\r\n>   允许服务持续运行的最大时长。\r\n>   如果服务持续运行超过了此处限制的时长，那么该服务将会被强制终止，同时将该服务变为失败(failed)状态。\r\n>   注意，此选项对 Type=oneshot 类型的服务无效，因为它们会在启动完成后立即终止。\r\n>   默认值为 \"infinity\" (不限时长)。\r\n\r\nWatchdogSec=\r\n\r\n>   设置该服务的看门狗(watchdog)的超时时长。 看门狗将在服务成功启动之后被启动。\r\n>   该服务在运行过程中必须周期性的以 \"WATCHDOG=1\" (\"keep-alive\r\n>   ping\")调用 [sd\\_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html) 函数。\r\n>   如果在两次调用之间的时间间隔大于这里设定的值，\r\n>   那么该服务将被视为失败(failed)状态， 并会被强制使用 SIGABRT 信号关闭。\r\n>   通过将 Restart= 设为 on-failure, on-watchdog, on-abnormal, always 之一，\r\n>   可以实现在失败状态下的自动重启该服务。\r\n>   这里设置的值将会通过 WATCHDOG\\_USEC= 环境变量传递给守护进程，\r\n>   这样就允许那些支持看门狗的服务自动启用\"keep-alive ping\"。 如果设置了此选项，\r\n>   那么必须将 NotifyAccess= 设为 main(此种情况下的隐含默认值) 或 all 。\r\n>   如果未指定时间单位，那么将视为以秒为单位。 例如设为\"20\"等价于设为\"20s\"。\r\n>   默认值\"0\"表示禁用看门狗功能。\r\n>   详见 [sd\\_watchdog\\_enabled(3)](http://www.jinbuguo.com/systemd/sd_watchdog_enabled.html) 与 [sd\\_event\\_set\\_watchdog(3)](http://www.jinbuguo.com/systemd/sd_event_set_watchdog.html) 手册。\r\n\r\nRestart=\r\n\r\n>   当服务进程正常退出、异常退出、被杀死、超时的时候， 是否重新启动该服务。\r\n>   所谓\"服务进程\"是指 ExecStartPre=, ExecStartPost=, ExecStop=, ExecStopPost=, ExecReload= 中设置的进程。\r\n>   当进程是由于 systemd 的正常操作(例如 **systemctl\r\n>   stop\\|restart**)而被停止时， 该服务不会被重新启动。\r\n>   所谓\"超时\"可以是看门狗的\"keep-alive ping\"超时， 也可以是 **systemctl\r\n>   start\\|reload\\|stop** 操作超时。\r\n\r\n>   该选项的值可以取 no, always, on-success, on-failure, on-abnormal, on-watchdog, on-abort 之一。 no(默认值)\r\n>   表示不会被重启。 always 表示会被无条件的重启。 on-success 表示仅在服务进程正常退出时重启，\r\n>   所谓\"正常退出\"是指： 退出码为\"0\"，\r\n>   或者进程收到 SIGHUP, SIGINT, SIGTERM, SIGPIPE 信号之一，\r\n>   并且退出码符合 SuccessExitStatus= 的设置。 on-failure 表示仅在服务进程异常退出时重启，\r\n>   所谓\"异常退出\"是指： 退出码不为\"0\"， 或者进程被强制杀死(包括 \"core\r\n>   dump\"以及收到 SIGHUP, SIGINT, SIGTERM, SIGPIPE 之外的其他信号)，\r\n>   或者进程由于看门狗或者 systemd 的操作超时而被杀死。\r\n\r\n>   **表 1. Restart= 的设置分别对应于哪些退出原因**\r\n\r\n| **退出原因(↓) Ι Restart= (→)** | **no** | **always** | **on-success** | **on-failure** | **on-abnormal** | **on-abort** | **on-watchdog** |\r\n|---------------------------------|--------|------------|----------------|----------------|-----------------|--------------|-----------------|\r\n| 正常退出                        |        | X          | X              |                |                 |              |                 |\r\n| 退出码不为\"0\"                   |        | X          |                | X              |                 |              |                 |\r\n| 进程被强制杀死                  |        | X          |                | X              | X               | X            |                 |\r\n| systemd 操作超时                |        | X          |                | X              | X               |              |                 |\r\n| 看门狗超时                      |        | X          |                | X              | X               |              | X               |\r\n\r\n>   注意如下两个例外情况(详见下文)：\r\n>   (1) RestartPreventExitStatus= 中列出的退出码或信号永远不会导致该服务被重启。\r\n>   (2) RestartForceExitStatus= 中列出的退出码或信号将会无条件的导致该服务被重启。\r\n\r\n>   对于需要长期持续运行的守护进程， 推荐设为 on-failure 以增强可用性。\r\n>   对于自身可以自主选择何时退出的服务， 推荐设为 on-abnormal\r\n\r\nSuccessExitStatus=\r\n\r\n>   额外定义附加的进程\"正常退出\"状态。\r\n>   可以设为一系列以空格分隔的数字退出码或者信号名称， 例如：\r\n\r\n>   SuccessExitStatus=1 2 8 SIGKILL\r\n\r\n>   表示当进程的退出码是 1, 2, 8 或被 SIGKILL 信号终止时，\r\n>   都可以视为\"正常退出\"。\r\n>   注意，退出码\"0\"以及 SIGHUP, SIGINT, SIGTERM, SIGPIPE 信号是标准的\"正常退出\"，\r\n>   不需要在此特别定义。\r\n\r\n>   注意，如果进程拥有自定义的信号处理器，\r\n>   并且在收到信号后通过调用 [\\_exit(2)](http://man7.org/linux/man-pages/man2/_exit.2.html) 退出，那么有关信号的信息就会丢失。\r\n>   在这种情况下，进程必须自己完成清理工作并使用相同的信号自杀。 参见 [Proper\r\n>   handling of SIGINT/SIGQUIT — How to be a proper\r\n>   program](http://www.cons.org/cracauer/sigint.html)\r\n\r\n>   如果多次使用此选项， 那么最终的结果将是多个列表的合并。 如果将此选项设为空，\r\n>   那么先前设置的列表将被清空。\r\n\r\nRestartPreventExitStatus=\r\n\r\n>   可以设为一系列以空格分隔的数字退出码或信号名称，\r\n>   当进程的退出码或收到的信号与此处的设置匹配时， 无论 Restart= 是如何设置的，\r\n>   该服务都将无条件的禁止重新启动。 例如：\r\n\r\n>   RestartPreventExitStatus=1 6 SIGABRT\r\n\r\n>   可以确保退出码 1, 6 与 SIGABRT 信号 不会导致该服务被自动重启。 默认值为空，\r\n>   表示完全遵守 Restart= 的设置。 如果多次使用此选项，\r\n>   那么最终的结果将是多个列表的合并。 如果将此选项设为空，\r\n>   那么先前设置的列表将被清空。\r\n\r\nRestartForceExitStatus=\r\n\r\n>   可以设为一系列以空格分隔的数字退出码或信号名称，\r\n>   当进程的退出码或收到的信号与此处的设置匹配时，\r\n>   无论 Restart= 是如何设置的，该服务都将无条件的被自动重新启动。\r\n>   默认值为空，表示完全遵守 Restart= 的设置。\r\n>   如果多次使用此选项，那么最终的结果将是多个列表的合并。\r\n>   如果将此选项设为空，那么先前设置的列表将被清空。\r\n\r\nPermissionsStartOnly=\r\n\r\n>   设为 yes\r\n>   表示所有与权限相关的执行选项(例如 User= 之类的选项，参见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 手册)仅对 ExecStart= 中的程序有效，而对 ExecStartPre=, ExecStartPost=, ExecReload=, ExecStop=, ExecStopPost= 中的程序无效。\r\n>   默认值 no 表示所有与权限相关的执行选项，\r\n>   对所有 Exec\\*= 系列选项中的程序都有效。\r\n\r\nRootDirectoryStartOnly=\r\n\r\n>   设为 yes\r\n>   表示根目录(参见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 中的 RootDirectory= 选项)仅对 ExecStart= 中的程序有效，\r\n>   而对 ExecStartPre=, ExecStartPost=, ExecReload=, ExecStop=,\r\n>   and ExecStopPost= 中的程序无效。 默认值 no 表示\r\n>   根目录对所有 Exec\\*= 系列选项中的程序都有效。\r\n\r\nNonBlocking=\r\n\r\n>   是否为所有基于socket启动传递的文件描述符设置非阻塞标记(O\\_NONBLOCK)。 设为\r\n>   yes 表示所有 ≥3 的文件描述符 (也就是 stdin, stdout, stderr 之外的文件描述符)\r\n>   都将被设为非阻塞模式。 该选项仅在与 socket 单元\r\n>   ([systemd.socket(5)](http://www.jinbuguo.com/systemd/systemd.socket.html))\r\n>   联用的时候才有意义。 默认值为 no\r\n\r\nNotifyAccess=\r\n\r\n>   设置通过 [sd\\_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html) 访问服务状态通知socket的模式。\r\n>   可以设为 none(默认值), main, all 之一。 none 表示不更新任何守护进程的状态，忽略所有状态更新消息。 main 表示仅接受主进程的状态更新消息。 all 表示接受该服务cgroup内所有进程的状态更新消息。\r\n>   当设置了 Type=notify 或 WatchdogSec= 的时候(见前文)，\r\n>   此选项只能被设为 main 或 all ， 如果未设置，那么隐含为 main\r\n\r\nSockets=\r\n\r\n>   设置一个socket单元的名称， 表示该服务在启动时应当从它继承socket文件描述符。\r\n>   通常并不需要明确设置此选项，\r\n>   因为所有与该服务同名(不算后缀)的socket单元的socket文件描述符，\r\n>   都会被自动的传递给派生进程。\r\n\r\n>   注意： (1)同一个socket文件描述符可以被传递给多个不同的进程(服务)。\r\n>   (2)当socket上有流量进入时， 被启动的可能是另一个不同于该服务的其他服务。\r\n>   换句话说就是：\r\n>   套接字单元中的 Sockets= 所指向的服务单元中的 Sockets= 未必要反向指回去。\r\n\r\n>   如果多次使用此选项， 那么最终的结果将是多个socket单元的合集。\r\n>   如果将此选项设为空， 那么先前设置的所有socket单元都将被清空。\r\n\r\nFailureAction=\r\n\r\n>   当该服务进入失败(failed)状态时所触发的动作。\r\n>   取值范围及值的含义都与 StartLimitAction= (参见 [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html))\r\n>   完全相同。 默认值为 none\r\n\r\nFileDescriptorStoreMax=\r\n\r\n>   允许在 systemd 中最多为该服务存储多少个使用 \"FDSTORE=1\"\r\n>   消息([sd\\_pid\\_notify\\_with\\_fds(3)](http://www.jinbuguo.com/systemd/sd_pid_notify_with_fds.html))\r\n>   的文件描述符， 默认值为\"0\"(不存储)。 用于实现重启该服务而不会丢失其状态\r\n>   (前提是该服务将各种状态序列化之后保存在 /run 中， 同时将文件描述符交给\r\n>   systemd 暂存)。 所有被 systemd 暂存的文件描述符\r\n>   都将在该服务重启之后交还给该服务的主进程。 所有被 systemd\r\n>   暂存的文件描述符都将在遇到如下两种情况时被自动关闭： (1)收到 POLLHUP 或\r\n>   POLLERR 信号； (2)该服务被彻底停止，并且没有任何剩余的任务队列\r\n\r\nUSBFunctionDescriptors=\r\n\r\n>   设为一个包含 [USB\r\n>   FunctionFS](https://www.kernel.org/doc/Documentation/usb/functionfs.txt) 描述符的文件路径，\r\n>   以实现 USB gadget 支持。 仅与配置了 ListenUSBFunction= 的 socket\r\n>   单元一起使用。该文件的内容将被写入 ep0 文件。\r\n\r\nUSBFunctionStrings=\r\n\r\n>   设为一个包含 [USB\r\n>   FunctionFS](https://www.kernel.org/doc/Documentation/usb/functionfs.txt) 字符串的文件路径。\r\n>   其行为与上面的 USBFunctionDescriptors= 类似。\r\n\r\n参见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 与 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册，以了解更多其他选项。\r\n\r\n命令行\r\n------\r\n\r\n本小节讲解 ExecStart=, ExecStartPre=, ExecStartPost=, ExecReload=, ExecStop=, ExecStopPost= 选项的命令行解析规则。\r\n\r\n如果要一次设置多个命令，那么可以使用分号(`;`)将多个命令行连接起来。\r\n注意，仅在设置了 Type=oneshot 的前提下，才可以一次设置多个命令。 分号自身必须用\r\n\"`\\;`\" 表示。\r\n\r\n每个命令行的内部以空格分隔， 第一项是要运行的命令， 随后的各项则是命令的参数。\r\n每一项的边界都可以用单引号或者双引号界定，\r\n而且还可以使用C语言风格的转义序列(详见下文的表格)。\r\n最后，行尾的反斜杠(\"`\\`\")将被视作续行符(借鉴了bash续行语法)。\r\n\r\n命令行的语法刻意保持了与shell的相似性， 但并不完全相同。 特别的， 重定向(\"`<`\",\r\n\"`<<`\", \"`>`\", \"`>>`\")、 管道(\"`|`\")、 后台运行(\"`&`\")，\r\n以及*其他下文未明确提及的符号*都不被支持。\r\n\r\n要运行的命令(第一项)必须使用绝对路径表示。\r\n可以在其中包含空格，但是不能包含控制字符。\r\n\r\n可以在各项命令参数中使用 \"`%`\"\r\n系列特殊符号(详见 [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html) 手册)，\r\n但不可用于命令自身(第一项)。\r\n\r\n支持 \"`${FOO}`\" 与 \"`$FOO`\" 两种不同的环境变量替换方式。\r\n具体说来就是：\r\n\"`${FOO}`\"的内容将原封不动的转化为一个单独的命令行参数，\r\n无论其中是否包含空格与引号，也无论它是否为空。\r\n\"`$FOO`\"的内容将被原封不动的插入命令行中，\r\n但对插入内容的解释却遵守一般的命令行解析规则。\r\n下面的两个例子，将能清晰的体现两者的差别：\r\n\r\n例(1)：\r\n```shell\r\nEnvironment=\"ONE=one\" \'TWO=two two\'\r\nExecStart=/bin/echo $ONE $TWO ${TWO}\r\n```\r\n这将给 **/bin/echo** 命令依次传递如下四个参数: \"one\", \"two\", \"two\", \"two two\"\r\n\r\n例(2)：\r\n```\r\nEnvironment=ONE=\'one\' \"TWO=\'two two\' too\" THREE=\r\nExecStart=/bin/echo ${ONE} ${TWO} ${THREE}\r\nExecStart=/bin/echo $ONE $TWO $THREE\r\n```\r\n这将导致 **/bin/echo** 被执行两次。 第一次被依次传递如下三个参数： \"\'one\'\",\r\n\"\'two two\' too\", \"\" ； 第二次被依次传递如下三个参数： \"one\", \"two two\", \"too\" 。\r\n\r\n此外，如果想要传递美元符号(`$`)自身， 则必须使用 \"`$$`\" 。\r\n而那些无法在替换时确定内容的变量将被当做空字符串。\r\n注意，不可以在第一项(也就是命令的绝对路径)中使用变量替换。\r\n\r\n注意，这里使用的变量必须已经在 Environment= 或 EnvironmentFile= 中定义。\r\n此外，在 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html) 手册的\"环境变量\"小节中列出的\"静态变量\"也可以使用。\r\n例如 `$USER` 就是一个\"静态变量\"， 而 `$TERM` 则不是。\r\n\r\n注意，这里的命令行并不直接支持shell命令，\r\n但是可以通过模仿下面这个变通的方法来实现：\r\n\r\n```\r\nExecStart=/bin/sh -c \'dmesg | tac\'\r\n```\r\n\r\n例一\r\n```\r\nExecStart=/bin/echo one ; /bin/echo \"two two\"\r\n```\r\n\r\n这将导致 **/bin/echo** 被执行两次。 第一次被传递了单独一个 \"one\" 参数；\r\n第二次被传递了单独一个 \"two two\" 参数。\r\n因为一次设置了多个命令，所以仅能用于 Type=oneshot 类型。\r\n\r\n例二\r\n```\r\nExecStart=/bin/echo / >/dev/null & \\; \\\r\n/bin/ls\r\n```\r\n\r\n这表示向 **/bin/echo** 命令传递五个参数：`\"/\", \">/dev/null\", \"&\", \";\", \"/bin/ls\"`\r\n\r\n**表 2. 可以在命令行与环境变量中使用的C语言风格的转义序列**\r\n\r\n| **转义序列** | **实际含义**                 |\r\n|--------------|------------------------------|\r\n| \"\\\\a\"        | 响铃                         |\r\n| \"\\\\b\"        | 退格                         |\r\n| \"\\\\f\"        | 换页                         |\r\n| \"\\\\n\"        | 换行                         |\r\n| \"\\\\r\"        | 回车                         |\r\n| \"\\\\t\"        | 制表符                       |\r\n| \"\\\\v\"        | 纵向制表符                   |\r\n| \"\\\\\\\\\"       | 反斜线                       |\r\n| \"\\\\\"\"        | 双引号                       |\r\n| \"\\\\\'\"        | 单引号                       |\r\n| \"\\\\s\"        | 空白                         |\r\n| \"\\\\x*xx*\"    | 十六进制数 *xx* 所对应的字符 |\r\n| \"\\\\*nnn*\"    | 八进制数 *nnn* 所对应的字符  |\r\n\r\n例子\r\n----\r\n\r\n**例 1. 简单服务**\r\n\r\n下面的单元文件创建了一个运行 /usr/sbin/foo-daemon 守护进程的服务。\r\n未设置 Type= 等价于 Type=simple 默认设置。 systemd 执行守护进程之后，\r\n即认为该单元已经启动成功。\r\n```shell\r\n[Unit]\r\nDescription=简单的Foo服务\r\n\r\n[Service]\r\nExecStart=/usr/sbin/foo-daemon\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n注意，本例中的 /usr/sbin/foo-daemon 必须在启动后持续运行到服务被停止。\r\n如果该进程只是为了派生守护进程，那么应该使用 Type=forking\r\n\r\n因为没有设置 ExecStop= 选项， 所以在停止服务时，systemd\r\n将会直接向该服务启动的所有进程发送 SIGTERM 信号。\r\n若超过指定时间依然存在未被杀死的进程，那么将会继续发送 SIGKILL 信号。\r\n详见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册。\r\n\r\n默认的 Type=simple 并不包含任何通知机制(例如通知\"服务启动成功\")。\r\n要想使用通知机制，应该将 Type= 设为其他非默认值： Type=notify 可用于能够理解\r\nsystemd\r\n通知协议的服务； Type=forking 可用于能将自身切换到后台的服务； Type=dbus 可用于能够在完成初始化之后获得一个\r\nD-Bus 名称的单元。\r\n\r\n**例 2. 一次性服务**\r\n\r\nType=oneshot 用于那些只需要执行一次性动作而不需要持久运行的单元，\r\n例如文件系统检查或者清理临时文件。 此类单元，\r\n将会在启动后一直等待指定的动作完成， 然后再回到停止状态。\r\n下面是一个执行清理动作的单元：\r\n\r\n```shell\r\n[Unit]\r\nDescription=清理老旧的 Foo 数据\r\n\r\n[Service]\r\nType=oneshot\r\nExecStart=/usr/sbin/foo-cleanup\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n注意，在 /usr/sbin/foo-cleanup 执行结束前，\r\n该服务一直处于\"启动中\"(activating)状态，而一旦执行结束，该服务又立即变为\"停止\"(inactive)状态。\r\n也就是说，对于 Type=oneshot 类型的服务，不存在\"活动\"(active)状态。\r\n这意味着，如果再一次启动该服务，将会再一次执行该服务定义的动作。\r\n注意，在先后顺序上晚于该服务的单元，\r\n将会一直等到该服务变成\"停止\"(inactive)状态后， 才会开始启动。\r\n\r\nType=oneshot 是唯一可以设置多个 ExecStart= 指令的服务类型。\r\n多个 ExecStart= 指令将按照它们出现的顺序依次执行，\r\n一旦遇到错误，就会立即停止，不再继续执行，\r\n同时该服务也将进入\"失败\"(failed)状态。\r\n\r\n**例 3. 可停止的一次性服务**\r\n\r\n有时候，单元需要执行一个程序以完成某个设置(启动)，\r\n然后又需要再执行另一个程序以撤消先前的设置(停止)，\r\n而在设置持续有效的时段中，该单元应该视为处于\"活动\"(active)状态，\r\n但实际上并无任何程序在持续运行。 网络配置服务就是一个典型的例子。\r\n此外，只能启动一次(不可多次启动)的一次性服务，也是一个例子。\r\n\r\n可以通过设置 RemainAfterExit=yes 来满足这种需求。 在这种情况下，systemd\r\n将会在启动成功后将该单元视为处于\"活动\"(active)状态(而不是\"停止\"(inactive)状态)。 RemainAfterExit=yes 虽然可以用于所有 Type= 类型，\r\n但是在实践中主要用于Type=oneshot 和 Type=simple 类型。 对于 Type=oneshot 类型，\r\nsystemd 一直等到服务启动成功之后，才会将该服务置于\"活动\"(active)状态。\r\n所以，依赖于该服务的其他单元必须等待该服务启动成功之后，才能启动。\r\n但是对于 Type=simple 类型，\r\n依赖于该服务的其他单元无需等待，将会和该服务同时并行启动。\r\n下面的类似展示了一个简单的静态防火墙服务：\r\n\r\n```shell\r\n[Unit]\r\nDescription=简单的静态防火墙\r\n\r\n[Service]\r\nType=oneshot\r\nRemainAfterExit=yes\r\nExecStart=/usr/local/sbin/simple-firewall-start\r\nExecStop=/usr/local/sbin/simple-firewall-stop\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n因为服务启动成功后一直处于\"活动\"(active)状态， 所以再次执行 **systemctl\r\nstart** 命令不会有任何效果。\r\n\r\n**例 4. 传统的服务**\r\n\r\n多数传统的守护进程(服务)在启动时会转入后台运行。 systemd\r\n通过 Type=forking 来支持这种工作方式。\r\n对于这种类型的服务，如果最初启动的进程尚未退出，\r\n那么该单元将依然处于\"启动中\"(activating)状态。 当最初的进程成功退出，\r\n并且至少有一个进程仍然在运行(并且 RemainAfterExit=no)，\r\n该服务才会被视为处于\"活动\"(active)状态。\r\n\r\n对于单进程的传统服务，当最初的进程成功退出后，\r\n将会只剩单独一个进程仍然在持续运行， systemd\r\n将会把这个唯一剩余的进程视为该服务的主进程。\r\n仅在这种情况下，才将可以在 ExecReload=, ExecStop= ...\r\n之类的选项中使用 \\$MAINPID 变量。\r\n\r\n对于多进程的传统服务，当最初的进程成功退出后，将会剩余多个进程在持续运行，\r\n因此，systemd 无法确定哪一个进程才是该服务的主进程。\r\n在这种情况下，不可以使用 \\$MAINPID 变量。 然而，如果主进程会创建传统的PID文件，\r\n那么应该将 PIDFile= 设为此PID文件的绝对路径， 以帮助 systemd\r\n从该PID文件中读取主进程的PID，从而帮助确定该服务的主进程。\r\n注意，守护进程必须在完成初始化之前写入PID文件， 否则可能会导致 systemd\r\n读取失败(读取时文件不存在)。\r\n\r\n下面是一个单进程传统服务的示例：\r\n\r\n```shell\r\n[Unit]\r\nDescription=一个单进程传统服务\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/sbin/my-simple-daemon -d\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n参见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 以了解如何结束服务进程。\r\n\r\n**例 5. DBus 服务**\r\n\r\n对于需要在 D-Bus 系统总线上注册一个名字的服务，\r\n应该使用 Type=dbus 并且设置相应的 BusName= 值。 该服务不可以派生任何子进程。\r\n一旦从 D-Bus 系统总线成功获取所需的名字，该服务即被视为初始化成功。\r\n下面是一个典型的 D-Bus 服务：\r\n\r\n```shell\r\n[Unit]\r\nDescription=一个简单的 DBus 服务\r\n\r\n[Service]\r\nType=dbus\r\nBusName=org.example.simple-dbus-service\r\nExecStart=/usr/sbin/simple-dbus-service\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n\r\n对于*基于 D-Bus 启动*的服务来说， 不可以包含 \"[Install]\" 小节， 而是应该在对应的\r\nD-Bus service 文件中设置 SystemdService= 选项，\r\n例如(/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service):\r\n\r\n```shell\r\n[D-BUS Service]\r\nName=org.example.simple-dbus-service\r\nExec=/usr/sbin/simple-dbus-service\r\nUser=root\r\nSystemdService=simple-dbus-service.service\r\n```\r\n\r\n参见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册以了解如何结束服务进程。\r\n\r\n**例 6. 能够通知初始化已完成的服务**\r\n\r\nType=simple 类型的服务非常容易编写， 但是无法将\"启动成功\"的消息及时通知给\r\nsystemd 是一个重大缺陷。 Type=notify 可以弥补该缺陷，\r\n它支持将\"启动成功\"的消息及时通知给 systemd 。 下面是一个典型的例子：\r\n\r\n```shell\r\n[Unit]\r\nDescription=Simple notifying service\r\n\r\n[Service]\r\nType=notify\r\nExecStart=/usr/sbin/simple-notifying-service\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n注意，该守护进程必须支持 systemd 通知协议， 否则 systemd\r\n将会认为该服务一直处于\"启动中\"(activating)状态，并在超时后将其杀死。\r\n关于如何支持该通知协议，参见 [sd\\_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html) 手册。\r\n\r\n参见 [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html) 手册以了解如何结束服务进程。\r\n\r\n参见\r\n----\r\n\r\n[systemd(1)](http://www.jinbuguo.com/systemd/systemd.html), [systemctl(1)](http://www.jinbuguo.com/systemd/systemctl.html), [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html), [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html), [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html), [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html), [systemd.directives(7)](http://www.jinbuguo.com/systemd/systemd.directives.html)\r\n\r\n\\----------------------------\r\n',1496731963602,1498928691485,NULL,2),(92458234085388,'junit+spring-test更方便的获取上下文对象','#在类钱添加注解\r\n重点是在类前加注释：\r\n```java\r\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\r\n```\r\n使用location来指定spring配置文件\r\n\r\n#继承`AbstractJUnit4SpringContextTests`类\r\n\r\n```java\r\npublic class MyTest extends AbstractJUnit4SpringContextTests {\r\n```\r\n\r\n#注入\r\n\r\n```java\r\n    @Resource\r\n    private RedisTemplate redisTemplate;\r\n```\r\n\r\n#示例\r\n\r\n测试类\r\n>MyTest.java\r\n\r\n```java\r\npackage com.test1.test;\r\n\r\nimport org.junit.Test;\r\nimport org.springframework.dao.DataAccessException;\r\nimport org.springframework.data.redis.connection.RedisConnection;\r\nimport org.springframework.data.redis.core.RedisCallback;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.RedisSerializer;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;\r\n\r\nimport javax.annotation.Resource;\r\n\r\n/**\r\n * Created by zhangbokang on 2017/6/6.\r\n */\r\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\r\npublic class MyTest extends AbstractJUnit4SpringContextTests {\r\n\r\n    @Resource\r\n    private RedisTemplate redisTemplate;\r\n\r\n    @Test\r\n    public void testRedisTemplate(){\r\n        System.out.println(redisTemplate);\r\n        //存一个值\r\n        Boolean bl = (Boolean) redisTemplate.execute(new RedisCallback<Boolean>() {\r\n            @Override\r\n            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {\r\n                RedisSerializer<String> redisSerializer = redisTemplate.getStringSerializer();\r\n                byte [] key = redisSerializer.serialize(\"mykey\");\r\n                byte [] value = redisSerializer.serialize(\"myvalue\");\r\n                return connection.setNX(key,value);\r\n            }\r\n        });\r\n        System.out.println(\"success:\"+bl);\r\n        //取值\r\n        String value = (String) redisTemplate.execute(new RedisCallback<Object>() {\r\n            @Override\r\n            public Object doInRedis(RedisConnection connection) throws DataAccessException {\r\n                RedisSerializer redisSerializer = redisTemplate.getStringSerializer();\r\n                byte [] key = redisSerializer.serialize(\"mykey\");\r\n                return redisSerializer.deserialize(connection.get(key));\r\n            }\r\n        });\r\n        System.out.println(\"value:\"+value);\r\n    }\r\n}\r\n```',1496744858165,1498928691521,NULL,11),(92458234085389,'Java日期转换','#添加依赖\r\n在gradle中添加\r\n```java\r\n// https://mvnrepository.com/artifact/org.apache.commons/commons-lang3\r\ncompile group: \'org.apache.commons\', name: \'commons-lang3\', version: \'3.4\'\r\n```\r\n#使用示例\r\n\r\n```java\r\nimport org.apache.commons.lang3.time.DateUtils\r\n\r\nLong visitTimeEndStamp = DateUtils.parseDate(visitTimeEnd,\"yyyy-MM-dd\").getTime();\r\n```\r\n\r\n- 说明：`visitTimeEnd`为一个`2017-01-01`样式的字符串。',1496918565627,1498928691555,NULL,3),(92458234085390,'Spring中Bean及@Bean的理解','Bean在Spring和SpringMVC中无所不在，将这个概念内化很重要，下面分享一下我的想法：\r\n\r\n \r\n\r\n#一、Bean是啥\r\n\r\n1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；\r\n\r\n \r\n\r\n2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；\r\n\r\n \r\n\r\n3、规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；\r\n\r\n \r\n\r\n4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了\r\n\r\n \r\n\r\n5、我们都在微博上@过某某，对方会优先看到这条信息，并给你反馈，那么在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean或者给出一个Bean\r\n\r\n#二、注解分为两类：\r\n\r\n1、一类是使用Bean，即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean；\r\n\r\n \r\n\r\n2、一类是注册Bean,@Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。\r\n\r\n \r\n\r\n#三、@Bean是啥？\r\n\r\n \r\n\r\n1、原理是什么？先看下源码中的部分内容：\r\n```\r\n \r\nIndicates that a method produces a bean to be managed by the Spring container.\r\n \r\n <h3>Overview</h3>\r\n \r\n <p>The names and semantics of the attributes to this annotation are intentionally\r\n similar to those of the {@code <bean/>} element in the Spring XML schema. For\r\n example:\r\n \r\n <pre class=\"code\">\r\n     @Bean\r\n     public MyBean myBean() {\r\n         // instantiate and configure MyBean obj\r\n         return obj;\r\n    }</pre>\r\n```\r\n　　意思是@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了\r\n\r\n 2、记住，@Bean就放在方法上，就是产生一个Bean，那你是不是又糊涂了，因为已经在你定义的类上加了@Configration等注册Bean的注解了，为啥还要用@Bean呢？这个我也不知道，下面我给个例子，一起探讨一下吧：\r\n```java\r\n\r\npackage com.edu.fruit;\r\n  //定义一个接口\r\n    public interface Fruit<T>{\r\n        //没有方法\r\n}\r\n \r\n/*\r\n*定义两个子类\r\n*/\r\npackage com.edu.fruit;\r\n     @Configuration\r\n     public class Apple implements Fruit<Integer>{//将Apple类约束为Integer类型\r\n \r\n}\r\n \r\npackage com.edu.fruit;\r\n     @Configuration\r\n     public class GinSeng implements Fruit<String>{//将GinSeng 类约束为String类型\r\n \r\n}\r\n/*\r\n*业务逻辑类\r\n*/\r\npackage com.edu.service;\r\n       @Configuration\r\n       public class FruitService {\r\n          @Autowired\r\n          private Apple apple;\r\n          @Autowired\r\n          private GinSeng ginseng;\r\n    //定义一个产生Bean的方法\r\n       @Bean(name=\"getApple\")\r\n       public Fruit<?> getApple(){\r\n       System.out.println(apple.getClass().getName().hashCode);\r\n         System.out.println(ginseng.getClass().getName().hashCode);\r\n       return new Apple();\r\n}\r\n}\r\n/*\r\n*测试类\r\n*/\r\n@RunWith(BlockJUnit4ClassRunner.class)\r\npublic class Config {\r\n    public Config(){\r\n        super(\"classpath:spring-fruit.xml\");\r\n    }\r\n    @Test\r\n    public void test(){\r\n        super.getBean(\"getApple\");//这个Bean从哪来，从上面的@Bean下面的方法中来，返回\r\n                                                          的是一个Apple类实例对象\r\n         \r\n    }\r\n}\r\n```\r\n从上面的例子也印证了我上面的总结的内容：\r\n\r\n1、凡是子类及带属性、方法的类都注册Bean到Spring中，交给它管理；\r\n\r\n2、@Bean 用在方法上，告诉Spring容器，你可以从下面这个方法中拿到一个Bean',1496985516502,1498928691595,NULL,1),(92458234085391,'Intellij IDEA把 “;” 自动放到行尾','可以使用这个键： `Crtl+Shift+Enter`，在IntelliJ的意思是complete current statement，应该叫当前语句自动完成吧，当您的语句不完全时，均可以使用该快捷键。',1497337825619,1498928691635,NULL,NULL),(92458234085392,'javascript对搜索结果的排序(使用indexOf)','#场景\r\n\r\n已经使用正则表达式等方法匹配出一组数据。\r\n匹配`myArr.spell`中包含`X`的。\r\n得到数组：\r\n```javascript\r\nvar myArr = [{\r\n	spell:\"XM\",\r\n	name:\"小明\",\r\n	age:12\r\n},{\r\n	spell:\"LXH\",\r\n	name:\"李晓红\",\r\n	age:15\r\n},{\r\n	spell:\"XFF\",\r\n	name:\"小飞飞\",\r\n	age:11\r\n}]\r\n```\r\n\r\n#要求\r\n\r\nX在前的显示在前面，比如匹配X，小明和小飞飞第一个字简拼是X，而李晓红第二个字简拼才是X，所以李晓红应该排在小明和小飞飞后面。\r\n\r\n#实现\r\n\r\n使用sort()和indexOf()来实现。\r\n\r\n```javascript\r\nmyArr.sort(function(obj1,obj2){\r\n	var spellNum1 = obj1.spell.indexOf(\"X\");\r\n	var spellNum2 = obj2.spell.indexOf(\"X\");\r\n	return spellNum1 < spellNum2 ? -1 : spellNum1 > spellNum2 ? 1 : 0;\r\n});\r\n```\r\n\r\n#参考资料\r\n\r\n>JavaScript sort() 方法\r\n\r\n[http://www.w3school.com.cn/jsref/jsref_sort.asp](http://www.w3school.com.cn/jsref/jsref_sort.asp)\r\n\r\n',1497510938773,1498928691666,NULL,NULL),(92458234085393,'mysql 将时间戳直接转换成日期时间','#MySQL时间戳格式化为日期时间函数\r\n\r\n`FROM_UNIXTIME(unix_timestamp,format)`\r\n\r\n- 返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。\r\n- format可以包含与`DATE_FORMAT()`函数列出的条目同样的修饰符。根据format字符串格式化date值。\r\n>下列修饰符可以被用在format字符串中： \r\n%M 月名字(January……December)    \r\n%W 星期名字(Sunday……Saturday)    \r\n%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）    \r\n%Y 年, 数字, 4 位    \r\n%y 年, 数字, 2 位    \r\n%a 缩写的星期名字(Sun……Sat)    \r\n%d 月份中的天数, 数字(00……31)    \r\n%e 月份中的天数, 数字(0……31)    \r\n%m 月, 数字(01……12)    \r\n%c 月, 数字(1……12)    \r\n%b 缩写的月份名字(Jan……Dec)   \r\n%j 一年中的天数(001……366)   \r\n%H 小时(00……23)   \r\n%k 小时(0……23)    \r\n%h 小时(01……12)    \r\n%I 小时(01……12)    \r\n%l 小时(1……12)    \r\n%i 分钟, 数字(00……59)\r\n%r 时间,12 小时(hh: mm: ss [AP]M)\r\n%T 时间,24 小时(hh: mm: ss)\r\n%S 秒(00……59)\r\n%s 秒(00……59)\r\n%p AM或PM\r\n%w 一个星期中的天数(0=Sunday ……6=Saturday ）\r\n%U 星期(0……52), 这里星期天是星期的第一天\r\n%u 星期(0……52), 这里星期一是星期的第一天\r\n%% 一个文字“%”\r\n\r\n\r\n---\r\n例：\r\n（直接使用数据库字段）\r\n```sql\r\nselect uid,userid,username,email,FROM_UNIXTIME(addtime,\'%Y年%m月%d\') from members;\r\n```\r\n以上例子是sql语句的例子，直接能将mysql的时间戳类型转换成日期格式\r\n\r\n```shell\r\nmysql>SELECT FROM_UNIXTIME( 1249488000, \'%Y%m%d\' )\r\n->20071120 \r\nmysql>SELECT FROM_UNIXTIME( 1249488000, \'%Y年%m月%d\' )\r\n->2007年11月20\r\n```\r\n \r\n#MySQL日期时间转换为时间戳函数\r\n\r\n`UNIX_TIMESTAMP()`是与之相对正好相反的时间函数，将日期时间转换为时间戳类型\r\n\r\n- 使用：\r\n`UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)`\r\n\r\n>若无参数调用，则返回一个 Unix timestamp (\'1970-01-01 00:00:00\' GMT 之后的秒数) 作为无符号整数。(当前时间戳)\r\n若用date 来调用 UNIX_TIMESTAMP()，它会将参数值以\'1970-01-01 00:00:00\' GMT后的秒数的形式返回。date 可以是一个 DATE 字符串、一个 DATETIME字符串、一个 TIMESTAMP或一个当地时间的YYMMDD 或YYYMMDD格式的数字。\r\n \r\n例如: \r\n```shell\r\nmysql> SELECT UNIX_TIMESTAMP(); （执行使得时间:2009-08-06 10:10:40）\r\n->1249524739 \r\nmysql> SELECT UNIX_TIMESTAMP(\'2009-08-06\');\r\n->1249488000 \r\n```\r\n\r\n[原文：http://blog.csdn.net/snn1410/article/details/7613100](http://blog.csdn.net/snn1410/article/details/7613100 \"原文：http://blog.csdn.net/snn1410/article/details/7613100\")\r\n\r\n',1496918565627,1498928691692,NULL,NULL),(92458234085394,'Java 读写Properties配置文件','#Java 读写Properties配置文件\r\n1.Properties类与Properties配置文件\r\n\r\n　　Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存属性集。不过Properties有特殊的地方，就是它的键和值都是字符串类型。\r\n\r\n2.Properties中的主要方法\r\n\r\n(1)load(InputStream inStream)\r\n\r\n 　　这个方法可以从.properties属性文件对应的文件输入流中，加载属性列表到Properties类对象。如下面的代码：\r\n\r\nProperties pro = new Properties();\r\nFileInputStream in = new FileInputStream(\"a.properties\");\r\npro.load(in);\r\nin.close();\r\n(2)store(OutputStream out, String comments)\r\n\r\n 　　这个方法将Properties类对象的属性列表保存到输出流中。如下面的代码：\r\n\r\nFileOutputStream oFile = new FileOutputStream(file, \"a.properties\");\r\npro.store(oFile, \"Comment\");\r\noFile.close();\r\n　　如果comments不为空，保存后的属性文件第一行会是#comments,表示注释信息；如果为空则没有注释信息。\r\n\r\n　　注释信息后面是属性文件的当前保存时间信息。\r\n\r\n(3)getProperty/setProperty\r\n\r\n 　　这两个方法是分别是获取和设置属性信息。\r\n\r\n3.代码实例\r\n\r\n 属性文件a.properties如下：\r\n\r\nname=root\r\npass=liu\r\nkey=value\r\n读取a.properties属性列表，与生成属性文件b.properties。代码如下：\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream; \r\nimport java.util.Iterator;\r\nimport java.util.Properties; \r\n\r\npublic class PropertyTest {\r\n    public static void main(String[] args) { \r\n        Properties prop = new Properties();     \r\n        try{\r\n            //读取属性文件a.properties\r\n            InputStream in = new BufferedInputStream (new FileInputStream(\"a.properties\"));\r\n            prop.load(in);     ///加载属性列表\r\n            Iterator<String> it=prop.stringPropertyNames().iterator();\r\n            while(it.hasNext()){\r\n                String key=it.next();\r\n                System.out.println(key+\":\"+prop.getProperty(key));\r\n            }\r\n            in.close();\r\n            \r\n            ///保存属性到b.properties文件\r\n            FileOutputStream oFile = new FileOutputStream(\"b.properties\", true);//true表示追加打开\r\n            prop.setProperty(\"phone\", \"10086\");\r\n            prop.store(oFile, \"The New properties file\");\r\n            oFile.close();\r\n        }\r\n        catch(Exception e){\r\n            System.out.println(e);\r\n        }\r\n    } \r\n}',1498213558246,1498928691722,NULL,NULL),(92458234085395,'Java/JavaWeb中读取资源文件','1、一般工程中使用I/O类指定文件的绝对路径读取\r\n\r\nFileInputStream fis = new FileInputStream(\"src/main/resources/zsm.properties\");\r\nppt.load(fis);\r\nString memAddr1 = ppt.getProperty(\"memAddr1\");\r\n \r\n\r\n2、Web工程中可以使用ServletContext或ClassLoader来读取\r\n\r\n　　2.1、通过ServletContext来读取资源文件，文件路径是相对于web项目（如/JspServletFeature）根路径而言的。\r\n\r\n　　2.2、通过ClassLoader来读取，文件路径是相对于类目录而言的（maven工程中一般为/target/classes）\r\n\r\n　　示例如下\r\n\r\n（1）文件位置\r\n\r\n　　放在src目录（或其子目录）下是相对于项目根目录如JspServletFeature的路径\r\n\r\n　　放在JavaResources下是相对于类目录即classes的目录\r\n\r\n（2）代码\r\n```java\r\n// 使用servletContext读取资源文件，相对于web项目的根路径(即JspServletFeature)\r\n        out.println(\"\\n使用servletContext读取资源文件，相对于web项目的根路径(即JspServletFeature):\");\r\n        readFileByServletContext(response, \"FileReadFile1.properties\");\r\n        readFileByServletContext(response, \"/FileReadFile1.properties\");\r\n        readFileByServletContext(response, \"WEB-INF/classes/FileReadFile2.properties\");\r\n        readFileByServletContext(response, \"/WEB-INF/classes/FileReadFile2.properties\");\r\n        readFileByServletContext(response, \"WEB-INF/classes/com/zsm/util/FileReadFile3.properties\");\r\n        readFileByServletContext(response, \"/WEB-INF/classes/com/zsm/util/FileReadFile3.properties\");\r\n        // 使用ClassLoader读取资源文件，相对于类目录(即classes)\r\n        out.println(\"\\n使用ClassLoader读取资源文件，相对于类目录(即classes):\");\r\n        readFileByClassLoader(response, \"../../FileReadFile1.properties\");\r\n        readFileByClassLoader(response, \"/../../FileReadFile1.properties\");\r\n        readFileByClassLoader(response, \"FileReadFile2.properties\");\r\n        readFileByClassLoader(response, \"/FileReadFile2.properties\");\r\n        readFileByClassLoader(response, \"com/zsm/util/FileReadFile3.properties\");\r\n        readFileByClassLoader(response, \"/com/zsm/util/FileReadFile3.properties\");\r\n\r\n    // 使用servletContext读取资源文件，相对于web项目的根路径(即JspServletFeature)\r\n    synchronized void readFileByServletContext(HttpServletResponse response, String filePath) throws IOException {\r\n        InputStream in = this.getServletContext().getResourceAsStream(filePath);\r\n        Properties prop = new Properties();\r\n        prop.load(in);\r\n        String fileName = prop.getProperty(\"fileName\");\r\n        String name = prop.getProperty(\"name\");\r\n        String company = prop.getProperty(\"company\");\r\n        in.close();\r\n        response.getWriter().println(MessageFormat.format(\"filePath={0},  fileName={1},  name={2},  company={3}\",\r\n                filePath, fileName, name, company));\r\n    }\r\n\r\n    // 使用ClassLoader读取资源文件，相对于类目录(即classes)\r\n    synchronized void readFileByClassLoader(HttpServletResponse response, String filePath) throws IOException {\r\n        // 获取到装载当前类的类装载器\r\n        ClassLoader loader = FileReadServlet.class.getClassLoader();\r\n        InputStream in = loader.getResourceAsStream(filePath);\r\n        Properties prop = new Properties();\r\n        prop.load(in);\r\n        String fileName = prop.getProperty(\"fileName\");\r\n        String name = prop.getProperty(\"name\");\r\n        String company = prop.getProperty(\"company\");\r\n        in.close();\r\n        response.getWriter().println(MessageFormat.format(\"filePath={0},  fileName={1},  name={2},  company={3}\",\r\n                filePath, fileName, name, company));\r\n    }\r\n```\r\n（3）结果\r\n\r\n\r\n',1496505094236,1498928691775,NULL,NULL),(92458234085396,'Hibernate集成Spring出现写操作在只读事物中的问题','#Hibernate集成Spring出现写操作在只读事物中的问题\r\n##问题描述\r\nSpring与Hibernate集成，且在web.xml中配置OpenSessionInViewFilter，目的是解决懒加载问题\r\n```xml\r\n   <!-- 解决Lazy Initial Exception问题 -->\r\n   <filter>\r\n          <filter-name>OpenSessionInViewFilter</filter-name>\r\n          <filter-class>\r\n         org.springframework.orm.hibernate3.support.OpenSessionInViewFilter\r\n          </filter-class>\r\n   </filter>\r\n   <filter-mapping>\r\n        <filter-name>OpenSessionInViewFilter</filter-name>\r\n         <url-pattern>*</url-pattern>\r\n   </filter-mapping>\r\n   <filter-mapping>\r\n        <filter-name>OpenSessionInViewFilter</filter-name>\r\n         <url-pattern>*.jsp</url-pattern>\r\n   </filter-mapping>\r\n```\r\n\r\n会开启OpenSessionInViewFilter来阻止延迟加载的错误，但是在我们开启OpenSessionInViewFilter这个过滤器的时候FlushMode就已经被默认设置为了MANUAL，如果FlushMode是MANUAL或NEVEL,在操作过程中 hibernate会将事务设置为readonly，所以在增加、删除或修改操作过程中会出现异常\r\nWrite operations are not allowed in read-onlymode (FlushMode.NEVER/MANUAL): Turn your Session into FlushMode.COMMIT/AUTO orremove \'readOnly\' marker from transaction definition.\r\n \r\n**如果方法没有被Spring事务管理器所管理到，默认的话事务是只读模式**\r\n\r\n注意：即使在未使用到OpenSessionInViewFilter的时候也很有可能出现该错误(我在单元测试的时候也碰到了)。\r\n \r\n##解决方法：\r\n我的Spring事务配置：\r\n```xml\r\n	<aop:config expose-proxy=\"true\">\r\n        <!-- 只对业务逻辑层实施事务 -->\r\n        <aop:pointcut id=\"txPointcut\" expression=\"execution(* com.zbkblog.service..*.*(..)) \"/>\r\n        <aop:advisor pointcut-ref=\"txPointcut\" advice-ref=\"txAdvice\"/>\r\n    </aop:config>\r\n```\r\n\r\n经过多次实践，我改成\r\n```xml\r\n	<aop:config expose-proxy=\"true\">\r\n        <!-- 只对业务逻辑层实施事务 -->\r\n        <aop:pointcut id=\"txPointcut\" expression=\"execution(* com.zbkblog.service..*.*(..)) || execution(* com.zbkblog.dao..*.*(..))\" />\r\n        <aop:advisor pointcut-ref=\"txPointcut\" advice-ref=\"txAdvice\"/>\r\n    </aop:config>\r\n```\r\n\r\n增加了对dao层的管理，这样的话就不会发生异常了',1495595754168,1498928691827,NULL,NULL),(92458234085397,'关于hibernate如何把原生sql查出的结果转化为对象','原文：[http://blog.csdn.net/qq_16055765/article/details/52712413](http://blog.csdn.net/qq_16055765/article/details/52712413)\r\n\r\n原生SQL查询执行的控制是通过SQLQuery接口进行的，通过执行Session.createSQLQuery()获取这个接口。下面来描述如何使用这个API进行查询。\r\n\r\n###16.1.1. 标量查询（Scalar queries） \r\n最基本的SQL查询就是获得一个标量（数值）的列表。\r\n```java\r\nsess.createSQLQuery(\"SELECT * FROM CATS\").list();\r\nsess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\r\n```\r\n它们都将返回一个Object数组(Object[])组成的List，数组每个元素都是CATS表的一个字段值。hibernate会使用ResultSetMetadata来判定返回的标量值的实际顺序和类型。\r\n\r\n如果要避免过多的使用ResultSetMetadata,或者只是为了更加明确的指名返回值，可以使用addScalar()。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT * FROM CATS\")\r\n .addScalar(\"ID\", Hibernate.LONG)\r\n .addScalar(\"NAME\", Hibernate.STRING)\r\n .addScalar(\"BIRTHDATE\", Hibernate.DATE)\r\n```\r\n\r\n这个查询指定了:\r\n\r\nSQL查询字符串\r\n\r\n要返回的字段和类型\r\n\r\n它仍然会返回Object数组,但是此时不再使用ResultSetMetdata,而是明确的将ID,NAME和BIRTHDATE按照Long,String和Short类型从resultset中取出。同时，也指明了就算query是使用*来查询的，可能获得超过列出的这三个字段，也仅仅会返回这三个字段。\r\n\r\n对全部或者部分的标量值不设置类型信息也是可以的。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT * FROM CATS\")\r\n .addScalar(\"ID\", Hibernate.LONG)\r\n .addScalar(\"NAME\")\r\n .addScalar(\"BIRTHDATE\")\r\n```\r\n基本上这和前面一个查询相同,只是此时使用ResultSetMetaData来决定NAME和BIRTHDATE的类型，而ID的类型是明确指出的。\r\n\r\n关于从ResultSetMetaData返回的Java.sql.Types是如何映射到Hibernate类型，是由方言(Dialect)控制的。假若某个指定的类型没有被映射，或者不是你所预期的类型，你可以通过Dialet的registerHibernateType调用自行定义。 \r\n###16.1.2. 实体查询(Entity queries) \r\n上面的查询都是返回标量值的，也就是从resultset中返回的“裸”数据。下面展示如何通过addEntity()让原生查询返回实体对象。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\r\nsess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat.class);\r\n```\r\n\r\n这个查询指定：\r\n\r\nSQL查询字符串\r\n\r\n要返回的实体\r\n\r\n假设Cat被映射为拥有ID,NAME和BIRTHDATE三个字段的类，以上的两个查询都返回一个List，每个元素都是一个Cat实体。\r\n\r\n假若实体在映射时有一个many-to-one的关联指向另外一个实体，在查询时必须也返回那个实体，否则会导致发生一个”column not found”的数据库错误。这些附加的字段可以使用*标注来自动返回，但我们希望还是明确指明，看下面这个具有指向Dog的many-to-one的例子：\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\").addEntity(Cat.class);\r\n```\r\n\r\n这样cat.getDog()就能正常运作。 \r\n###16.1.3. 处理关联和集合类(Handling associations and collections) \r\n通过提前抓取将Dog连接获得，而避免初始化proxy带来的额外开销也是可能的。这是通过addJoin()方法进行的，这个方法可以让你将关联或集合连接进来。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\r\n .addEntity(\"cat\", Cat.class)\r\n .addJoin(\"cat.dog\");\r\n```\r\n\r\n上面这个例子中，返回的Cat对象，其dog属性被完全初始化了，不再需要数据库的额外操作。注意，我们加了一个别名(“cat”)，以便指明join的目标属性路径。通过同样的提前连接也可以作用于集合类，例如，假若Cat有一个指向Dog的一对多关联。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\r\n .addEntity(\"cat\", Cat.class)\r\n .addJoin(\"cat.dogs\");\r\n```\r\n\r\n到此为止，我们碰到了天花板：若不对SQL查询进行增强，这些已经是在Hibernate中使用原生SQL查询所能做到的最大可能了。下面的问题即将出现：返回多个同样类型的实体怎么办？或者默认的别名/字段不够又怎么办？\r\n\r\n###16.1.4. 返回多个实体(Returning multiple entities) \r\n到目前为止,结果集字段名被假定为和映射文件中指定的的字段名是一致的。假若SQL查询连接了多个表，同一个字段名可能在多个表中出现多次，这就会造成问题。\r\n下面的查询中需要使用字段别名注射（这个例子本身会失败）：\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\r\n .addEntity(\"cat\", Cat.class)\r\n .addEntity(\"mother\", Cat.class)\r\n```\r\n\r\n这个查询的本意是希望每行返回两个Cat实例，一个是cat,另一个是它的妈妈。但是因为它们的字段名被映射为相同的，而且在某些数据库中，返回的字段别名是“c.ID”,”c.NAME”这样的形式，而它们和在映射文件中的名字（”ID”和”NAME”）不匹配，这就会造成失败。\r\n\r\n下面的形式可以解决字段名重复：\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID\")\r\n .addEntity(\"cat\", Cat.class)\r\n .addEntity(\"mother\", Cat.class)\r\n```\r\n\r\n这个查询指明：\r\n\r\nSQL查询语句，其中包含占位附来让Hibernate注射字段别名\r\n\r\n查询返回的实体\r\n\r\n上面使用的{cat.}和{mother.}标记是作为“所有属性”的简写形式出现的。当然你也可以明确地罗列出字段名，但在这个例子里面我们让Hibernate来为每个属性注射SQL字段别名。字段别名的占位符是属性名加上表别名的前缀。在下面的例子中，我们从另外一个表（cat_log）中通过映射元数据中的指定获取Cat和它的妈妈。注意，要是我们愿意，我们甚至可以在where子句中使用属性别名。\r\n\r\n```java\r\nString sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \r\n         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} \" +\r\n         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\r\n\r\nList loggedCats = sess.createSQLQuery(sql)\r\n        .addEntity(\"cat\", Cat.class)\r\n        .addEntity(\"mother\", Cat.class).list()\r\n```\r\n\r\n####16.1.4.1. 别名和属性引用(Alias and property references) \r\n大多数情况下，都需要上面的属性注射，但在使用更加复杂的映射，比如复合属性、通过标识符构造继承树，以及集合类等等情况下，也有一些特别的别名，来允许Hibernate注射合适的别名。\r\n\r\n下表列出了使用别名注射参数的不同可能性。注意：下面结果中的别名只是示例，实用时每个别名需要唯一并且不同的名字。\r\n\r\n表 16.1. 别名注射(alias injection names)\r\n\r\n\r\n描述 语法 示例\r\n简单属性 {[aliasname].[propertyname] A_NAME as {item.name} \r\n复合属性 {[aliasname].[componentname].[propertyname]} CURRENCY as {item.amount.currency}, VALUE as {item.amount.value} \r\n实体辨别器(Discriminator of an entity) {[aliasname].class} DISC as {item.class} \r\n实体的所有属性 {[aliasname].} {item.} \r\n集合键(collection key) {[aliasname].key} ORGID as {coll.key} \r\n集合id {[aliasname].id} EMPID as {coll.id} \r\n集合元素 {[aliasname].element} XID as {coll.element} \r\n集合元素的属性 {[aliasname].element.[propertyname]} NAME as {coll.element.name} \r\n集合元素的所有属性 {[aliasname].element.} {coll.element.} \r\n集合的所有属性 {[aliasname].} {coll.} \r\n###16.1.5. 返回非受管实体(Returning non-managed entities) \r\n可以对原生sql 查询使用ResultTransformer。这会返回不受Hibernate管理的实体。\r\n\r\n```java\r\nsess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\r\n        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))\r\n```\r\n\r\n这个查询指定：\r\n\r\nSQL查询字符串\r\n\r\n结果转换器(result transformer)\r\n\r\n上面的查询将会返回CatDTO的列表,它将被实例化并且将NAME和BIRTHDAY的值注射入对应的属性或者字段。 \r\n###16.1.6. 处理继承（Handling inheritance） \r\n原生SQL查询假若其查询结果实体是继承树中的一部分，它必须包含基类和所有子类的所有属性。 \r\n###16.1.7. 参数（Parameters） \r\n原生查询支持位置参数和命名参数：\r\n\r\n```java\r\nQuery query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?\").addEntity(Cat.class);\r\nList pusList = query.setString(0, \"Pus%\").list();\r\n\r\nquery = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\").addEntity(Cat.class);\r\nList pusList = query.setString(\"name\", \"Pus%\").list();\r\n```\r\n',1495595754168,1498928691883,NULL,NULL),(92458234085398,'jsTree中文参考资料','[jsTree中文参考资料](http://blog.csdn.net/qq_24472595/article/details/70053863 \"jsTree中文参考资料\")',1498646466298,1498928691938,NULL,NULL),(92458234085399,'Hibernate关联映射-参考资料','[Hibernate关联关系配置(一对多、一对一和多对多)](http://blog.csdn.net/u013126379/article/details/52217335 \"Hibernate关联关系配置(一对多、一对一和多对多)\")\r\n\r\n',1495595754168,1498928691985,NULL,NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
